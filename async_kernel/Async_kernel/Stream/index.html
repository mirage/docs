<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Stream (async_kernel.Async_kernel.Stream)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_kernel</a> &#x00BB; <a href="../index.html">Async_kernel</a> &#x00BB; Stream</nav><header><h1>Module <code>Async_kernel.Stream</code></h1><p>An immutable sequence of values, with a possibly incomplete tail that may be extended asynchronously.</p><p>For most applications one should use <a href="../Pipe/index.html"><code>Pipe</code></a> instead of Stream. One justifiable usage of <code>Stream</code> rather than <code>Pipe</code> is in single-writer, multi-consumer (multicast) scenarios where pushback is not required.</p><p>The basic primitive operation for getting the next element out of stream is <code>Stream.next</code>, which (asynchronously) returns the element and the rest of the stream.</p></header><div class="content"><div class="spec module" id="module-Deferred" class="anchored"><a href="#module-Deferred" class="anchor"></a><code><span class="keyword">module</span> <a href="Deferred/index.html">Deferred</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span> = <span><span class="type-var">'a</span> <a href="../Tail/Stream/index.html#type-t">Tail.Stream.t</a></span></code></div><div><p><code>sexp_of_t t f</code> returns a sexp of all of the elements currently available in the stream. It is just for display purposes. There is no <code>t_of_sexp</code>.</p></div></div><div><div class="spec include"><div class="doc"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></div></div></div></div><div><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span>(<span><span class="type-var">'a</span> <a href="../Tail/index.html#type-t">Tail.t</a></span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>create f</code> returns a stream <code>t</code> and calls <code>f tail</code>, where the elements of the stream are determined as the tail is extended, and the end of the stream is reached when the tail is closed.</p></div></div><div><div class="spec type" id="type-next" class="anchored"><a href="#type-next" class="anchor"></a><code><span class="keyword">type</span> <span>'a next</span> = </code><table><tr id="type-next.Nil" class="anchored"><td class="def variant constructor"><a href="#type-next.Nil" class="anchor"></a><code>| <span class="constructor">Nil</span></code></td></tr><tr id="type-next.Cons" class="anchored"><td class="def variant constructor"><a href="#type-next.Cons" class="anchor"></a><code>| <span class="constructor">Cons</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></td></tr></table></div><div><p><code>next t</code> returns a deferred that will become determined when the next part of the stream is determined. This is <code>Cons (v, t')</code>, where v is the next element of the stream and t' is the rest of the stream, or with Nil at the end of the stream.</p></div></div><div class="spec value" id="val-next" class="anchored"><a href="#val-next" class="anchor"></a><code><span class="keyword">val</span> next : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-next">next</a></span> <a href="Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><div class="spec value" id="val-first_exn" class="anchored"><a href="#val-first_exn" class="anchor"></a><code><span class="keyword">val</span> first_exn : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>first_exn t</code> returns a deferred that becomes determined with the first element of <code>t</code>.</p></div></div><aside><p>Streams can be converted to and from lists. Although, conversion to a list returns a deferred, because the stream is determined asynchronously.</p></aside><div><div class="spec value" id="val-of_list" class="anchored"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>of_list l</code> returns a stream with the elements of list l.</p></div></div><div><div class="spec value" id="val-to_list" class="anchored"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>to_list t</code> returns a deferred that will become determined with the list of elements in t, if the end of t is reached.</p></div></div><div><div class="spec value" id="val-of_fun" class="anchored"><a href="#val-of_fun" class="anchor"></a><code><span class="keyword">val</span> of_fun : <span>(unit <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Deferred/index.html#type-t">Deferred.t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>of_fun f</code> returns a stream whose elements are determined by calling <code>f</code> forever.</p></div></div><div><div class="spec value" id="val-copy_to_tail" class="anchored"><a href="#val-copy_to_tail" class="anchor"></a><code><span class="keyword">val</span> copy_to_tail : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Tail/index.html#type-t">Tail.t</a></span> <span>&#45;&gt;</span> <span>unit <a href="Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>copy_to_tail t tail</code> reads elements from <code>t</code> and puts them in <code>tail</code>, until the end of <code>t</code> is reached.</p></div></div><aside><p>Sequence operations ---------------------------------------------------------------------- There are the usual sequence operations:</p><pre>      append, fold, iter, map, filter_map, take</pre><p>There are also deferred variants:</p><pre>      iter', map', filter_map'</pre><p>These take anonymous functions that return deferreds generalizing the usual sequence operation and allowing the client to control the rate at which the sequence is processed.</p></aside><div><div class="spec value" id="val-append" class="anchored"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>append t1 t2</code> returns a stream with all the values of t1, in order, and if t1 ends, these values are followed by all the values of t2.</p></div></div><div><div class="spec value" id="val-concat" class="anchored"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>concat t</code> takes a stream of streams and produces a stream that is the concatenation of each stream in order (you see all of stream 1, then all of stream 2... etc.)</p></div></div><div><div class="spec value" id="val-available_now" class="anchored"><a href="#val-available_now" class="anchor"></a><code><span class="keyword">val</span> available_now : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>available_now t</code> returns t prefix of t that is available now, along with the rest of the stream.</p></div></div><div><div class="spec value" id="val-filter_deprecated" class="anchored"><a href="#val-filter_deprecated" class="anchor"></a><code><span class="keyword">val</span> filter_deprecated : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>filter_deprecated s ~f</code> returns a stream with one element, v, for each v in s such with f v = true.</p><p>Using <code>filter_deprecated</code> can easily lead to space leaks. It is better to use <code>Async.Pipe</code> than <code>Async.Stream</code>.</p></div></div><div><div class="spec value" id="val-filter_map_deprecated" class="anchored"><a href="#val-filter_map_deprecated" class="anchor"></a><code><span class="keyword">val</span> filter_map_deprecated : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>filter_map_deprecated s ~f</code> returns a stream with one element, v', for each v in s such with f v = Some v'.</p><p>Using <code>filter_map_deprecated</code> can easily lead to space leaks. It is better to use <code>Async.Pipe</code> than <code>Async.Stream</code>.</p></div></div><div><div class="spec value" id="val-fold'" class="anchored"><a href="#val-fold'" class="anchor"></a><code><span class="keyword">val</span> fold' : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'b</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="Deferred/index.html#type-t">Deferred.t</a></span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>fold' t ~init ~f</code> is like list fold, walking over the elements of the stream in order, as they become available. <code>fold'</code> returns a deferred that will yield the final value of the accumulator, if the end of the stream is reached.</p></div></div><div><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'b</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>fold t ~init ~f</code> is a variant of <code>fold'</code> in which <code>f</code> does not return a deferred.</p></div></div><div><div class="spec value" id="val-iter'" class="anchored"><a href="#val-iter'" class="anchor"></a><code><span class="keyword">val</span> iter' : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span>unit <a href="Deferred/index.html#type-t">Deferred.t</a></span>)</span></span> <span>&#45;&gt;</span> <span>unit <a href="Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>iter' t ~f</code> applies <code>f</code> to each element of the stream in turn, as they become available. It continues onto the next element only after the deferred returned by <code>f</code> becomes determined.</p></div></div><div><div class="spec value" id="val-closed" class="anchored"><a href="#val-closed" class="anchor"></a><code><span class="keyword">val</span> closed : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit <a href="Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>closed t</code> returns a deferred that becomes determined when the end of <code>t</code> is reached.</p></div></div><div><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> unit</code></div><div><p><code>iter t ~f</code> = <code>don't_wait_for (iter' t ~f:(fun a -&gt; f a; return ()))</code></p></div></div><div><div class="spec value" id="val-take_until" class="anchored"><a href="#val-take_until" class="anchor"></a><code><span class="keyword">val</span> take_until : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit <a href="Deferred/index.html#type-t">Deferred.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>take_until t d</code> returns a stream <code>t'</code> that has the same elements as <code>t</code> up until <code>d</code> becomes determined.</p></div></div><div><div class="spec value" id="val-iter_durably'" class="anchored"><a href="#val-iter_durably'" class="anchor"></a><code><span class="keyword">val</span> iter_durably' : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span>unit <a href="Deferred/index.html#type-t">Deferred.t</a></span>)</span></span> <span>&#45;&gt;</span> <span>unit <a href="Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>iter_durably' t ~f</code> is like <code>iter' t ~f</code>, except if <code>f</code> raises an exception it continues with the next element of the stream *and* reraises the exception (to the monitor in scope when iter_durably was called).</p><p><code>iter_durably t ~f</code> is like <code>iter t ~f</code>, except if <code>f</code> raises an exception it continues with the next element of the stream *and* reraises the exception (to the monitor in scope when iter_durably was called).</p><p><code>iter_durably_report_end t ~f</code> is equivalent to <code>iter_durably' t ~f:(fun x -&gt; return
    (f x))</code> but it is more efficient</p></div></div><div class="spec value" id="val-iter_durably" class="anchored"><a href="#val-iter_durably" class="anchor"></a><code><span class="keyword">val</span> iter_durably : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> unit</code></div><div class="spec value" id="val-iter_durably_report_end" class="anchored"><a href="#val-iter_durably_report_end" class="anchor"></a><code><span class="keyword">val</span> iter_durably_report_end : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>unit <a href="Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><div class="spec value" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>int <a href="Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>length s</code> returns a deferred that is determined when the end of s is reached, taking the value of the number of elements in s</p></div></div><div><div class="spec value" id="val-map'" class="anchored"><a href="#val-map'" class="anchor"></a><code><span class="keyword">val</span> map' : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="Deferred/index.html#type-t">Deferred.t</a></span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>map' t f</code> creates a new stream that with one element, (f v), for each element v of t.</p></div></div><div><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>map t ~f</code> creates a new stream that with one element, (f v), for each element v of t. <code>map t f</code> = <code>map' t ~f:(fun a -&gt; return (f a))</code>.</p></div></div><div><div class="spec value" id="val-first_n" class="anchored"><a href="#val-first_n" class="anchor"></a><code><span class="keyword">val</span> first_n : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>first_n t n</code> returns a stream with the first n elements of t, if t has n or more elements, or it returns t.</p></div></div><aside><p>Stream generation ----------------------------------------------------------------------</p></aside><div><div class="spec value" id="val-unfold" class="anchored"><a href="#val-unfold" class="anchor"></a><code><span class="keyword">val</span> unfold : <span class="type-var">'b</span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span> <a href="Deferred/index.html#type-t">Deferred.t</a></span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>unfold b f</code> returns a stream <code>a1; a2; ...; an</code> whose elements are determined by the equations:</p><pre>      b0 = b
      Some (a1, b1) = f b0
      Some (a2, b2) = f b1
      ...
      None = f bn</pre></div></div><aside><p>Miscellaneous operations ----------------------------------------------------------------------</p></aside><div><div class="spec value" id="val-split" class="anchored"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : <span>?&#8288;stop:<span>unit <a href="Deferred/index.html#type-t">Deferred.t</a></span></span> <span>&#45;&gt;</span> <span>?&#8288;f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span>[ `Continue <span><span>| `Found</span> of <span class="type-var">'b</span></span> ]</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> * <span><span>[ `End_of_stream <span><span>| `Stopped</span> of <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></span> <span><span>| `Found</span> of <span class="type-var">'b</span> * <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></span> ]</span> <a href="Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>split ~stop ~f t</code> returns a pair <code>(p, d)</code>, where <code>p</code> is a prefix of <code>t</code> that ends for one of three reasons:</p><pre>      1. [t] ends
      2. stop becomes determined
      3. f returns `Found</pre><p>The deferred <code>d</code> describes why the prefix ended, and returns the suffix of the stream in case (2) or (3).</p></div></div><div><div class="spec value" id="val-find" class="anchored"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span>[ `End_of_stream <span><span>| `Found</span> of <span class="type-var">'a</span> * <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></span> ]</span> <a href="Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>find ~f t</code> returns a deferred that becomes determined when <code>f x</code> is true for some element of <code>t</code>, or if the end of the stream is reached</p></div></div><div><div class="spec value" id="val-ungroup" class="anchored"><a href="#val-ungroup" class="anchor"></a><code><span class="keyword">val</span> ungroup : <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>ungroup t</code> takes a stream of lists and unpacks the items from each list into a single stream</p></div></div><div><div class="spec value" id="val-interleave" class="anchored"><a href="#val-interleave" class="anchor"></a><code><span class="keyword">val</span> interleave : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></div><div><p><code>interleave list</code> takes a stream of streams and returns a stream of their items interleaved as they become determined. The interleaved stream will be closed when the outer stream and all of the inner streams have been closed.</p></div></div></div></body></html>