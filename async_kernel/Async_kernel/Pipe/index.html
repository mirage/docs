<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Pipe (async_kernel.Async_kernel.Pipe)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> – <a href="../../index.html">async_kernel</a> &#x00BB; <a href="../index.html">Async_kernel</a> &#x00BB; Pipe</nav><header><h1>Module <code>Async_kernel.Pipe</code></h1><p>A buffered FIFO communication channel.</p><p>A pipe has a &quot;writer&quot; end and a &quot;reader&quot; end. The intent is that a writer feeds values into the pipe and then waits until it is notified that it should put more data in (referred to as &quot;pushback&quot;).</p><p>Each pipe contains a buffer that is a queue of values that have been written to the pipe but not yet read from the pipe. The length of the queue is not bounded; whenever the pipe is written to, values are immediately enqueued. However, writers are supposed to respect pushback from readers, either via the <code>unit Deferred.t</code> returned by <code>write</code> calls or by explicitly calling <code>pushback</code>.</p><p>If a pipe is empty, then readers queue up, waiting for values to be written. As soon as values are written, if a reader is available to consume them, the values will be handed to the reader.</p><p>One can use <code>downstream_flushed</code> to get notified by a pipe when all prior writes have been consumed by a reader.</p><p>There are distinct <code>Reader</code> and <code>Writer</code> modules and types, but all of the operations on readers and writers are available directly from the <code>Pipe</code> module.</p></header><nav class="toc"><ul><li><a href="#reader-and-writer-modules">Reader and Writer modules</a></li><li><a href="#creation">Creation</a></li><li><a href="#closing">Closing</a></li><li><a href="#flushing">Flushing</a></li><li><a href="#generic-pipe-operations">Generic pipe operations</a></li><li><a href="#writing">Writing</a></li><li><a href="#reading">Reading</a></li><li><a href="#sequence-functions">Sequence functions</a></li><li><a href="#miscellaneous">Miscellaneous</a></li><li><a href="#size-budget">Size budget</a></li><li><a href="#debugging">Debugging</a></li></ul></nav><div class="content"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'phantom) t</span></code></div><div><div class="spec include"><div class="doc"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'phantom</span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'phantom</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></div></div></div></div><div class="spec type" id="type-pipe" class="anchored"><a href="#type-pipe" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'phantom) pipe</span> = <span><span>(<span class="type-var">'a</span>, <span class="type-var">'phantom</span>)</span> <a href="index.html#type-t">t</a></span></code></div><div><div class="spec include"><div class="doc"><div class="spec value" id="val-sexp_of_pipe" class="anchored"><a href="#val-sexp_of_pipe" class="anchor"></a><code><span class="keyword">val</span> sexp_of_pipe : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'phantom</span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'phantom</span>)</span> <a href="index.html#type-pipe">pipe</a></span> <span>&#45;&gt;</span> <a href="../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></div></div></div></div><h3 id="reader-and-writer-modules"><a href="#reader-and-writer-modules" class="anchor"></a>Reader and Writer modules</h3><aside><p>These provide reader- and writer-specific types for the base pipe type.</p></aside><div class="spec module" id="module-Writer" class="anchored"><a href="#module-Writer" class="anchor"></a><code><span class="keyword">module</span> <a href="Writer/index.html">Writer</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Reader" class="anchored"><a href="#module-Reader" class="anchor"></a><code><span class="keyword">module</span> <a href="Reader/index.html">Reader</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><h3 id="creation"><a href="#creation" class="anchor"></a>Creation</h3><div><div class="spec value" id="val-create_reader" class="anchored"><a href="#val-create_reader" class="anchor"></a><code><span class="keyword">val</span> create_reader : <span>close_on_exception:bool</span> <span>&#45;&gt;</span> <span>(<span><span class="type-var">'a</span> <a href="Writer/index.html#type-t">Writer.t</a></span> <span>&#45;&gt;</span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><p><code>create_reader ~close_on_exception f</code> creates a new pipe, applies <code>f</code> to its writer end, and returns its reader end. <code>create_reader</code> closes the writer end when the result of <code>f</code> becomes determined. If <code>f</code> raises, then the exception is raised to the caller of <code>create_reader</code>. Whether or not <code>create_reader</code> closes the writer end upon <code>f</code> raising is determined by <code>close_on_exception</code>.</p><p>Choosing <code>~close_on_exception:false</code> is recommended, because normally closing the write end of a pipe is taken to mean that the writer completed successfully. With <code>close_on_exception:true</code>, the caller will both see the pipe closed and an exception will be raised to the monitor in effect when <code>create_reader</code> was called. There is a race between those two actions, which can easily lead to confusion or bugs.</p></div></div><div><div class="spec value" id="val-create_writer" class="anchored"><a href="#val-create_writer" class="anchor"></a><code><span class="keyword">val</span> create_writer : <span>(<span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Writer/index.html#type-t">Writer.t</a></span></code></div><div><p><code>create_writer</code> is symmetric with <a href="index.html#val-create_reader"><code>create_reader</code></a>. It creates a new pipe, applies <code>f</code> to its reader end, and returns its writer end. <code>create_writer</code> calls <code>close_read</code> when the result of <code>f</code> becomes determined. If <code>f</code> raises, <code>create_writer</code> closes the pipe and raises the exception to the caller of <code>create_writer</code>. <code>create_writer</code> closes on exception, unlike <code>create_reader</code>, because closing closing the read end of a pipe is a signal to the writer that the consumer has failed.</p></div></div><div class="spec value" id="val-init" class="anchored"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : <span>(<span><span class="type-var">'a</span> <a href="Writer/index.html#type-t">Writer.t</a></span> <span>&#45;&gt;</span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : unit <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> * <span><span class="type-var">'a</span> <a href="Writer/index.html#type-t">Writer.t</a></span></code></div><div><p><code>create ()</code> creates a new pipe. It is preferable to use <code>create_reader</code> or <code>create_writer</code> instead of <code>create</code>, since they provide exception handling and automatic closing of the pipe.</p></div></div><div><div class="spec value" id="val-of_list" class="anchored"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><p><code>of_list l</code> returns a closed pipe reader filled with the contents of <code>l</code>.</p></div></div><div><div class="spec value" id="val-singleton" class="anchored"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val</span> singleton : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><p><code>singleton x</code> returns a closed pipe reader filled with the single value <code>x</code>.</p></div></div><div><div class="spec value" id="val-unfold" class="anchored"><a href="#val-unfold" class="anchor"></a><code><span class="keyword">val</span> unfold : <span>init:<span class="type-var">'s</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'s</span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'s</span>)</span> option</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><p><code>unfold ~init ~f</code> returns a pipe that it fills with <code>'a</code>s by repeatedly applying <code>f</code> to values of the state type <code>'s</code>. When <code>f</code> returns <code>None</code>, the resulting pipe is closed. <code>unfold</code> respects pushback on the resulting pipe. If <code>f</code> raises, then the pipe is not closed.</p><p>For example, to create a pipe of natural numbers:</p><pre><code>Pipe.unfold ~init:0 ~f:(fun n -&gt; return (Some (n, n+1))) </code></pre></div></div><div><div class="spec value" id="val-of_sequence" class="anchored"><a href="#val-of_sequence" class="anchor"></a><code><span class="keyword">val</span> of_sequence : <span><span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Sequence/index.html#type-t">Core_kernel.Sequence.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><p><code>of_sequence sequence</code> returns a pipe reader that gets filled with the elements of <code>sequence</code>. <code>of_sequence</code> respects pushback on the resulting pipe.</p></div></div><div><div class="spec type" id="type-to_sequence_elt" class="anchored"><a href="#type-to_sequence_elt" class="anchor"></a><code><span class="keyword">type</span> <span>'a to_sequence_elt</span> = </code><table><tr id="type-to_sequence_elt.Value" class="anchored"><td class="def variant constructor"><a href="#type-to_sequence_elt.Value" class="anchor"></a><code>| <span class="constructor">Value</span> <span class="keyword">of</span> <span class="type-var">'a</span></code></td></tr><tr id="type-to_sequence_elt.Wait_for" class="anchored"><td class="def variant constructor"><a href="#type-to_sequence_elt.Wait_for" class="anchor"></a><code>| <span class="constructor">Wait_for</span> : <span><span class="type-var">_</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-to_sequence_elt">to_sequence_elt</a></span></code></td></tr></table></div><div><p><code>to_sequence reader</code> returns a sequence that can be consumed to extract values from <code>reader</code>. If <code>Wait_for d</code> is returned, the consumer must wait for <code>d</code> to become determined before pulling the next value. Repeatedly asking for the next value without waiting on <code>d</code> will infinite loop.</p></div></div><div class="spec value" id="val-to_sequence" class="anchored"><a href="#val-to_sequence" class="anchor"></a><code><span class="keyword">val</span> to_sequence : <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-to_sequence_elt">to_sequence_elt</a></span> <a href="../../../core_kernel/Core_kernel/Sequence/index.html#type-t">Core_kernel.Sequence.t</a></span></code></div><h3 id="closing"><a href="#closing" class="anchor"></a>Closing</h3><div><div class="spec value" id="val-close" class="anchored"><a href="#val-close" class="anchor"></a><code><span class="keyword">val</span> close : <span><span class="type-var">_</span> <a href="Writer/index.html#type-t">Writer.t</a></span> <span>&#45;&gt;</span> unit</code></div><div><p><code>close t</code> closes the write end of the pipe:</p><ul><li>Future write attempts will fail, raising an exception.</li></ul><ul><li>If, at the time of the close, there are reads blocked waiting for data, these reads will unblock, producing <code>`Eof</code>.</li></ul><ul><li>Future read attempts will drain the data that was in the pipe at the time of the close, until the pipe's buffer has been exhausted; subsequent reads will immediately get <code>`Eof</code>.</li></ul><p>Thus, after a pipe has been closed, reads never block.</p><p><code>close</code> is idempotent.</p></div></div><div><div class="spec value" id="val-close_read" class="anchored"><a href="#val-close_read" class="anchor"></a><code><span class="keyword">val</span> close_read : <span><span class="type-var">_</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> unit</code></div><div><p><code>close_read t</code> closes both the read and write ends of the pipe. It does everything <code>close</code> does, and in addition:</p><ul><li>all pending flushes become determined with <code>`Reader_closed</code>.</li><li>the pipe buffer is cleared.</li><li>all subsequent reads will get <code>`Eof</code>.</li></ul></div></div><div><div class="spec value" id="val-is_closed" class="anchored"><a href="#val-is_closed" class="anchor"></a><code><span class="keyword">val</span> is_closed : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></div><div><p><code>is_closed t</code> returns <code>true</code> iff <code>close t</code> or <code>close_read t</code> has been called.</p></div></div><div><div class="spec value" id="val-closed" class="anchored"><a href="#val-closed" class="anchor"></a><code><span class="keyword">val</span> closed : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>closed t</code> returns a deferred that becomes determined when <code>close t</code> or <code>close_read t</code> is called.</p></div></div><h3 id="flushing"><a href="#flushing" class="anchor"></a>Flushing</h3><div class="spec module" id="module-Flushed_result" class="anchored"><a href="#module-Flushed_result" class="anchor"></a><code><span class="keyword">module</span> <a href="Flushed_result/index.html">Flushed_result</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><aside><p>Deferreds returned by <code>upstream_flushed</code> and <code>downstream_flushed</code> become determined when all values written prior to the call have been consumed, or if the reader end of the pipe is closed. The difference between &quot;upstream&quot; and &quot;downstream&quot; comes if one has a chain of pipes that are linked (e.g., by <code>Pipe.map</code>):</p><pre>P1 --&gt; P2 --&gt; P3</pre><p>Calling <code>downstream_flushed P2</code> ensures that everything in P2 has made it out of P3. Calling <code>upstream_flushed P2</code> ensures that everything in P1 has made it out of P3. More generally, <code>downstream_flushed</code> starts at the current pipe and follows the chain to the final downstream consumer(s). <code>upstream_flushed</code> follows the chain to the initial upstream pipe(s), and then calls <code>downstream_flushed</code>.</p><p>For a pipe in isolation, &quot;consumed&quot; means &quot;read from the pipe&quot;. However, for pipes linked together with <code>transfer</code> or any function built from <code>transfer</code>, &quot;consumed&quot; means &quot;propagated all the way downstream through the chain and read from the final pipe in the chain&quot;. Furthermore, for a pipe ultimately connected to an <code>Async.Writer</code>, &quot;consumed&quot; means the OS write() system call has completed on the bytes read from the final pipe in the chain.</p><p>The following <code>Pipe</code> functions automatically link their input and output pipes together so that <code>*_flushed</code> on upstream pipes will propagate to downstream pipes: <code>transfer*</code>, <code>map*</code>, <code>filter_map*</code>, <code>filter</code>, <code>interleave</code>, <code>concat</code>. There is <em>not</em> automatic linking with <code>iter*</code>; however, user code can customize the behavior of flush functions using <a href="Consumer/index.html"><code>Consumer</code></a>.</p></aside><div class="spec value" id="val-upstream_flushed" class="anchored"><a href="#val-upstream_flushed" class="anchor"></a><code><span class="keyword">val</span> upstream_flushed : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="Flushed_result/index.html#type-t">Flushed_result.t</a> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div class="spec value" id="val-downstream_flushed" class="anchored"><a href="#val-downstream_flushed" class="anchor"></a><code><span class="keyword">val</span> downstream_flushed : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="Flushed_result/index.html#type-t">Flushed_result.t</a> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div class="spec module" id="module-Consumer" class="anchored"><a href="#module-Consumer" class="anchor"></a><code><span class="keyword">module</span> <a href="Consumer/index.html">Consumer</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec value" id="val-add_consumer" class="anchored"><a href="#val-add_consumer" class="anchor"></a><code><span class="keyword">val</span> add_consumer : <span><span class="type-var">_</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>downstream_flushed:<span>(unit <span>&#45;&gt;</span> <span><a href="Flushed_result/index.html#type-t">Flushed_result.t</a> <a href="../Deferred/index.html#type-t">Deferred.t</a></span>)</span></span> <span>&#45;&gt;</span> <a href="Consumer/index.html#type-t">Consumer.t</a></code></div><div><p><code>add_consumer reader ~downstream_flushed</code> creates a new consumer of <code>reader</code>, and causes future calls to <code>flushed_downstream reader</code> to take this consumer into account. Thereafter, <code>Pipe.flushed_downstream reader</code> will first ensure that values previously written to <code>reader</code> have been read, then that they have been sent downstream by the consumer that read them, and finally that they have been flushed downstream.</p><p>One should only supply the resulting consumer to read operations on <code>reader</code>. Using a consumer created from one reader with another reader will raise an exception.</p></div></div><h3 id="generic-pipe-operations"><a href="#generic-pipe-operations" class="anchor"></a>Generic pipe operations</h3><aside><p>These operations apply to all values of type <code>(_, _) t</code>, that is, both readers and writers.</p></aside><div><div class="spec value" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></div><div><p><code>length t</code> returns the number of elements currently queued in <code>t</code>.</p></div></div><div><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></div><div><p><code>is_empty t</code> is true iff there are no values in the pipe.</p></div></div><h3 id="writing"><a href="#writing" class="anchor"></a>Writing</h3><aside><p>The write operations return a deferred value that is determined when either (1) it is OK to write again to the pipe or (2) the pipe has been closed. This deferred is the data-producer's interface to the pipe pushback mechanism: it tells the producer when it should proceed after doing a write -- either to produce and write more data to the pipe, or to abandon production entirely. The pushback mechanism is just advisory: a producer task can, but typically should not, dump arbitrary amounts of data into a pipe even if there is no consumer draining it.</p><p>Producers that write a sequence of values to a pipe should be aware that the consumers who read from the pipe can close the pipe early -- that is, before the producer has finished doing all of its writes. If this happens, further writes will raise an exception. To avoid these errors, all writes must be atomically guarded by <code>is_closed</code> tests. Thus, a typical writer loop should look like this:</p><pre><code>  fun countup hi w = (* Send the ints in range \[0,hi) to writer W. *)
    let rec loop i =
      if i &lt; hi and not (is_closed w) then (* Guard write w/closed test. *)
  write i w &gt;&gt;&gt;            (* Do the write then block until datum     *)
  fun () -&gt; loop (i+1)     (*   fits or the pipe is closed.           *)
  else close w (* No harm done if reader has already closed the pipe.*)
in
loop 0 </code></pre><p>If the pipe's consumer stops reading early and closes the pipe, <code>countup</code> won't error out trying to write further values down the pipe: it will immediately wake up and exit.</p></aside><div><div class="spec value" id="val-pushback" class="anchored"><a href="#val-pushback" class="anchor"></a><code><span class="keyword">val</span> pushback : <span><span class="type-var">'a</span> <a href="Writer/index.html#type-t">Writer.t</a></span> <span>&#45;&gt;</span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>pushback writer</code> becomes determined when either <code>writer</code> has been closed or the pipe can accept a new write.</p></div></div><div><div class="spec value" id="val-write" class="anchored"><a href="#val-write" class="anchor"></a><code><span class="keyword">val</span> write : <span><span class="type-var">'a</span> <a href="Writer/index.html#type-t">Writer.t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>write writer a</code> enqueues <code>a</code> in <code>writer</code>, returning a pushback deferred, as described above.</p><p><code>transfer_in writer ~from:q</code> transfers the elements from <code>q</code> into <code>writer</code>, leaving <code>q</code> empty, and returning a pushback deferred.</p><p><code>write_without_pushback</code> and <code>transfer_in_without_pushback</code> are alternatives to <code>transfer_in</code> and <code>write</code> that can be used when you don't care about the pushback deferred. They add data to the pipe and return immediately.</p><p>The following equivalences hold:</p><ul><li><code>write t a = write_without_pushback t a; pushback t</code></li><li><code>transfer_in t ~from = transfer_in_without_pushback t ~from; pushback t</code></li></ul><p>If <code>is_closed writer</code>, then all of these functions raise.</p></div></div><div class="spec value" id="val-write_without_pushback" class="anchored"><a href="#val-write_without_pushback" class="anchor"></a><code><span class="keyword">val</span> write_without_pushback : <span><span class="type-var">'a</span> <a href="Writer/index.html#type-t">Writer.t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></div><div class="spec value" id="val-transfer_in" class="anchored"><a href="#val-transfer_in" class="anchor"></a><code><span class="keyword">val</span> transfer_in : <span><span class="type-var">'a</span> <a href="Writer/index.html#type-t">Writer.t</a></span> <span>&#45;&gt;</span> <span>from:<span><span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Queue/index.html#type-t">Core_kernel.Queue.t</a></span></span> <span>&#45;&gt;</span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div class="spec value" id="val-transfer_in_without_pushback" class="anchored"><a href="#val-transfer_in_without_pushback" class="anchor"></a><code><span class="keyword">val</span> transfer_in_without_pushback : <span><span class="type-var">'a</span> <a href="Writer/index.html#type-t">Writer.t</a></span> <span>&#45;&gt;</span> <span>from:<span><span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Queue/index.html#type-t">Core_kernel.Queue.t</a></span></span> <span>&#45;&gt;</span> unit</code></div><div><div class="spec value" id="val-write_when_ready" class="anchored"><a href="#val-write_when_ready" class="anchor"></a><code><span class="keyword">val</span> write_when_ready : <span><span class="type-var">'a</span> <a href="Writer/index.html#type-t">Writer.t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span>[ `Closed <span><span>| `Ok</span> of <span class="type-var">'b</span></span> ]</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>write_when_ready writer ~f</code> waits until there is space available in the pipe, and then calls <code>f write</code>, where <code>write</code> can be used by <code>f</code> to write a single value into the pipe at a time. <code>write_when_ready</code> guarantees that the pipe is open when it calls <code>f</code>, and hence that the writes will succeed, unless <code>f</code> itself closes the pipe.</p></div></div><div><div class="spec value" id="val-write_if_open" class="anchored"><a href="#val-write_if_open" class="anchor"></a><code><span class="keyword">val</span> write_if_open : <span><span class="type-var">'a</span> <a href="Writer/index.html#type-t">Writer.t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>write_if_open w e</code> is equivalent to:</p><pre><code>let x = e in
if not (is_closed w) then (write w x) else (return ()) </code></pre><p>Note the difference in allocation and potential side effects when <code>w</code> is closed and <code>e</code> is a complex expression.</p><p><code>write_without_pushback_if_open</code> is the same as <code>write_if_open</code>, except it calls <code>write_without_pushback</code> instead of <code>write</code>.</p></div></div><div class="spec value" id="val-write_without_pushback_if_open" class="anchored"><a href="#val-write_without_pushback_if_open" class="anchor"></a><code><span class="keyword">val</span> write_without_pushback_if_open : <span><span class="type-var">'a</span> <a href="Writer/index.html#type-t">Writer.t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></div><h3 id="reading"><a href="#reading" class="anchor"></a>Reading</h3><aside><p>With two special exceptions, all read procedures have a best-effort/forward-progress semantics:</p><ul><li>Best effort: When you do a read, you get what's available <em>right now</em>, which might be less than you requested.</li></ul><ul><li>Forward progress: However, if <em>nothing is available</em>, you block until some data comes in (unless you're at EOF, in which case there's obviously no point in waiting). So the only time you ever get an empty, 0-item read is when you're at EOF.</li></ul><p>The best-effort semantics allows you to program in a style that processes data in big slabs, yet also moves data through your processing in as timely a way as possible.</p><p>The forward-progress semantics means that every call produces <em>some</em> data, so you can process an n-element input with at most n reads; you cannot burn an unbounded number of cycles &quot;spinning&quot; doing an unbounded number of empty-result &quot;polling&quot; calls (which, in a non-preemptive system like Async could lock up the process).</p><p>The two exceptions to best-effort/forward-progress semantics are <code>read_now</code>, which polls for data, thus abandoning the forward-progress guarantee, and <code>read_exactly</code>, which loops until it has read the entire amount requested (or encountered EOF), thus abandoning the best-effort guarantee of timeliness.</p></aside><div><div class="spec value" id="val-read'" class="anchored"><a href="#val-read'" class="anchor"></a><code><span class="keyword">val</span> read' : <span>?&#8288;consumer:<a href="Consumer/index.html#type-t">Consumer.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;max_queue_length:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span><span>[ `Eof <span><span>| `Ok</span> of <span><span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Queue/index.html#type-t">Core_kernel.Queue.t</a></span></span> ]</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>read' pipe</code> reads values available in the pipe, as soon as any value becomes available. The resulting queue will satisfy <code>0 &lt; Queue.length q &lt;= max_queue_length</code>. <code>read'</code> raises if <code>max_queue_length &lt;= 0</code>. The <code>consumer</code> is used to extend the meaning of values being flushed (see the <code>Consumer</code> module above).</p></div></div><div><div class="spec value" id="val-read" class="anchored"><a href="#val-read" class="anchor"></a><code><span class="keyword">val</span> read : <span>?&#8288;consumer:<a href="Consumer/index.html#type-t">Consumer.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span><span>[ `Eof <span><span>| `Ok</span> of <span class="type-var">'a</span></span> ]</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>read pipe</code> reads a single value from the pipe. The <code>consumer</code> is used to extend the meaning of values being flushed (see the <code>Consumer</code> module above).</p></div></div><div><div class="spec value" id="val-read_at_most" class="anchored"><a href="#val-read_at_most" class="anchor"></a><code><span class="keyword">val</span> read_at_most : <span>?&#8288;consumer:<a href="Consumer/index.html#type-t">Consumer.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>num_values:int</span> <span>&#45;&gt;</span> <span><span>[ `Eof <span><span>| `Ok</span> of <span><span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Queue/index.html#type-t">Core_kernel.Queue.t</a></span></span> ]</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>read_at_most t ~num_values</code> is <code>read' t ~max_queue_length:num_values</code>.</p></div></div><div><div class="spec value" id="val-read_exactly" class="anchored"><a href="#val-read_exactly" class="anchor"></a><code><span class="keyword">val</span> read_exactly : <span>?&#8288;consumer:<a href="Consumer/index.html#type-t">Consumer.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>num_values:int</span> <span>&#45;&gt;</span> <span><span>[ `Eof <span><span>| `Fewer</span> of <span><span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Queue/index.html#type-t">Core_kernel.Queue.t</a></span></span> <span><span>| `Exactly</span> of <span><span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Queue/index.html#type-t">Core_kernel.Queue.t</a></span></span> ]</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>read_exactly r ~num_values</code> reads exactly <code>num_values</code> items, unless EOF is encountered. <code>read_exactly</code> performs a sequence of <code>read_at_most</code> operations, so there is no guarantee that the queue of values it returns comprise a contiguous segment of the written stream of values -- other readers might pick off elements in-between <code>read_exactly</code>'s atomic reads. <code>read_exactly</code> raises if <code>num_values &lt;= 0</code>. The <code>consumer</code> is used to extend the meaning of values being flushed (see the <code>Consumer</code> module above).</p></div></div><div><div class="spec value" id="val-read_now'" class="anchored"><a href="#val-read_now'" class="anchor"></a><code><span class="keyword">val</span> read_now' : <span>?&#8288;consumer:<a href="Consumer/index.html#type-t">Consumer.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;max_queue_length:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>[ `Eof <span>| `Nothing_available</span> <span><span>| `Ok</span> of <span><span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Queue/index.html#type-t">Core_kernel.Queue.t</a></span></span> ]</span></code></div><div><p><code>read_now' reader</code> reads values from <code>reader</code> that are immediately available. If <code>reader</code> is closed, <code>read_now'</code> returns <code>`Eof</code>. If <code>reader</code> is empty, <code>read_now'</code> returns <code>`Nothing_available</code>. Otherwise, <code>`Ok q</code> is returned, and the resulting queue will satisfy <code>0 &lt; Q.length q &lt;= max_queue_length</code>. The <code>consumer</code> is used to extend the meaning of values being flushed (see the <code>Consumer</code> module above).</p></div></div><div><div class="spec value" id="val-read_now" class="anchored"><a href="#val-read_now" class="anchor"></a><code><span class="keyword">val</span> read_now : <span>?&#8288;consumer:<a href="Consumer/index.html#type-t">Consumer.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>[ `Eof <span>| `Nothing_available</span> <span><span>| `Ok</span> of <span class="type-var">'a</span></span> ]</span></code></div><div><p><code>read_now</code> is like <code>read_now'</code>, except that it reads a single value rather than everything that is available.</p></div></div><div><div class="spec value" id="val-read_now_at_most" class="anchored"><a href="#val-read_now_at_most" class="anchor"></a><code><span class="keyword">val</span> read_now_at_most : <span>?&#8288;consumer:<a href="Consumer/index.html#type-t">Consumer.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>num_values:int</span> <span>&#45;&gt;</span> <span>[ `Eof <span>| `Nothing_available</span> <span><span>| `Ok</span> of <span><span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Queue/index.html#type-t">Core_kernel.Queue.t</a></span></span> ]</span></code></div><div><p><code>read_now_at_most t ~num_values</code> is <code>read_now' t ~max_queue_length:num_values</code></p></div></div><div class="spec value" id="val-peek" class="anchored"><a href="#val-peek" class="anchor"></a><code><span class="keyword">val</span> peek : <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></div><div><div class="spec value" id="val-clear" class="anchored"><a href="#val-clear" class="anchor"></a><code><span class="keyword">val</span> clear : <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> unit</code></div><div><p><code>clear reader</code> consumes all of the values currently in <code>reader</code>, and all blocked flushes become determined with <code>`Ok</code>.</p></div></div><div><div class="spec value" id="val-read_all" class="anchored"><a href="#val-read_all" class="anchor"></a><code><span class="keyword">val</span> read_all : <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Queue/index.html#type-t">Core_kernel.Queue.t</a></span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>read_all reader</code> reads all the values from the pipe until it is closed. An alternative name might be <code>Reader.to_queue</code>.</p></div></div><div><div class="spec value" id="val-values_available" class="anchored"><a href="#val-values_available" class="anchor"></a><code><span class="keyword">val</span> values_available : <span><span class="type-var">_</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span><span>[ `Eof <span>| `Ok</span> ]</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>values_available reader</code> returns a deferred that becomes determined when there are values in the pipe. If there are multiple readers (a rare situation), there is no guarantee that some other reader hasn't become active because of ordinary Async scheduling and removed some or all of the values between the time the result of <code>values_available</code> becomes determined and the time something waiting <code>upon</code> that result runs.</p><p><code>values_available</code> is useful when one wants to <code>choose</code> on values being available in a pipe, so that one can be sure and not remove values and drop them on the floor.</p><p><code>values_available</code> is roughly equivalent to <code>read' ~max_queue_length:0</code>.</p></div></div><div><div class="spec value" id="val-read_choice" class="anchored"><a href="#val-read_choice" class="anchor"></a><code><span class="keyword">val</span> read_choice : <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span><span>[ `Eof <span><span>| `Ok</span> of <span class="type-var">'a</span></span> <span>| `Nothing_available</span> ]</span> <a href="../Deferred/index.html#type-choice">Deferred.choice</a></span></code></div><div><p><code>read_choice reader</code> is:</p><pre><code>choice
  (values_available reader)
  (fun (_ : [ `Ok | `Eof ]) -&gt; read_now reader) </code></pre><p><code>read_choice</code> consumes a value from <code>reader</code> iff the choice is taken. <code>read_choice</code> exists to discourage the broken idiom:</p><pre><code>choice (read reader) (fun ...) </code></pre><p>which is broken because it reads from <code>reader</code> even if the choice isn't taken. <code>`Nothing_available</code> can only be returned if there is a race condition with one or more other consumers.</p><p><code>read_choice_single_consumer_exn reader [%here]</code> is like <code>read_choice reader</code>, but it raises in the case of <code>`Nothing_available</code>. It is intended to be used when <code>reader</code> has no other consumers.</p></div></div><div class="spec value" id="val-read_choice_single_consumer_exn" class="anchored"><a href="#val-read_choice_single_consumer_exn" class="anchor"></a><code><span class="keyword">val</span> read_choice_single_consumer_exn : <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <a href="../../../core_kernel/Core_kernel/Source_code_position/index.html#type-t">Core_kernel.Source_code_position.t</a> <span>&#45;&gt;</span> <span><span>[ `Eof <span><span>| `Ok</span> of <span class="type-var">'a</span></span> ]</span> <a href="../Deferred/index.html#type-choice">Deferred.choice</a></span></code></div><h3 id="sequence-functions"><a href="#sequence-functions" class="anchor"></a>Sequence functions</h3><div class="spec module" id="module-Flushed" class="anchored"><a href="#module-Flushed" class="anchor"></a><code><span class="keyword">module</span> <a href="Flushed/index.html">Flushed</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><aside><p>Issues: </p><ul><li><p>Scalar &amp; batch sequence processing:</p><p>Each of the sequence functions (<code>fold</code>, <code>iter</code>, <code>transfer</code>, <code>map</code>) comes in two versions: &quot;scalar&quot; and &quot;batch&quot; processing. The scalar version has the ordinary type for <code>f</code>, which handles an element at a time in a non-deferred way. In the batch version, <code>f</code> deals with a queue of elements from the pipe at a time, and can block, which will cause pushback on writers due to elements not being consumed.</p></li><li><p>Early-close and functions that copy between pipes:</p><p>Some functions (<code>transfer</code>, <code>map</code>, <code>filter_map</code>, <code>filter</code>, <code>interleave</code>, <code>concat</code>, and their primed, batch-processing variants) spawn a background task that copies data from some upstream pipe to some downstream pipe, perhaps with some processing inserted in between. These copying tasks finish under two circumstances. The standard, &quot;normal&quot; case is when the copying task gets EOF from the upstream pipe -- there is no more data to copy. In this case, the copying task closes the downstream pipe, if necessary, and exits.</p><p>Somewhat less common is when the downstream consumer decides to stop reading early, while the upstream producer is still sending data to the copy task. (E.g., perhaps the consumer was searching its incoming stream for some value, and it found that value, so there's no need to search further.) In this case, the consumer closes its pipe to indicate it's done reading values. When the copy task discovers that its downstream pipe is closed, it propagates the close to the upstream producer by closing its pipe and stops processing.</p></li></ul></aside><div><div class="spec value" id="val-fold'" class="anchored"><a href="#val-fold'" class="anchor"></a><code><span class="keyword">val</span> fold' : <span>?&#8288;flushed:<a href="Flushed/index.html#type-t">Flushed.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;max_queue_length:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'accum</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'accum</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Queue/index.html#type-t">Core_kernel.Queue.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'accum</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'accum</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>fold' reader ~init ~f</code> reads a batch of elements from <code>reader</code>, supplies them to <code>f</code>, waits for <code>f</code> to finish, and then repeats. <code>fold'</code> finishes when the call to <code>f</code> on the final batch of elements from <code>reader</code> finishes.</p></div></div><aside><p><code>fold reader ~init ~f</code> folds over the elements of <code>reader</code>, consuming them as they come in. <code>fold</code> finishes when the final call to <code>f</code> returns.</p></aside><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span>?&#8288;flushed:<a href="Flushed/index.html#type-t">Flushed.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'accum</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'accum</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'accum</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'accum</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div class="spec value" id="val-fold_without_pushback" class="anchored"><a href="#val-fold_without_pushback" class="anchor"></a><code><span class="keyword">val</span> fold_without_pushback : <span>?&#8288;consumer:<a href="Consumer/index.html#type-t">Consumer.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'accum</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'accum</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'accum</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'accum</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><div class="spec value" id="val-iter'" class="anchored"><a href="#val-iter'" class="anchor"></a><code><span class="keyword">val</span> iter' : <span>?&#8288;continue_on_error:bool</span> <span>&#45;&gt;</span> <span>?&#8288;flushed:<a href="Flushed/index.html#type-t">Flushed.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;max_queue_length:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span><span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Queue/index.html#type-t">Core_kernel.Queue.t</a></span> <span>&#45;&gt;</span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span>)</span></span> <span>&#45;&gt;</span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>iter' reader ~f </code> repeatedly applies <code>f</code> to batches of elements of <code>reader</code>, waiting for each call to <code>f</code> to finish before continuing. The deferred returned by <code>iter'</code> becomes determined when the call to <code>f</code> on the final batch of elements finishes. <code>~continue_on_error:true</code> causes the iteration to continue even if <code>f</code> raises.</p><p><code>~flushed:When_value_processed</code> means values in batch <code>b</code> are flushed only after <code>f
    b</code> is filled.</p></div></div><div><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>?&#8288;continue_on_error:bool</span> <span>&#45;&gt;</span> <span>?&#8288;flushed:<a href="Flushed/index.html#type-t">Flushed.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span>)</span></span> <span>&#45;&gt;</span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>iter t f</code> is a specialization of <code>iter'</code> that applies the <code>f</code> to each element in the batch, waiting for one call to <code>f</code> to finish before making the next call to <code>f</code>.</p></div></div><div><div class="spec value" id="val-iter_without_pushback" class="anchored"><a href="#val-iter_without_pushback" class="anchor"></a><code><span class="keyword">val</span> iter_without_pushback : <span>?&#8288;consumer:<a href="Consumer/index.html#type-t">Consumer.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;continue_on_error:bool</span> <span>&#45;&gt;</span> <span>?&#8288;max_iterations_per_job:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>iter_without_pushback t ~f</code> applies <code>f</code> to each element in <code>t</code>, without giving <code>f</code> a chance to pushback on the iteration continuing. If <code>f</code> raises on some element of <code>t</code>, <code>iter_without_pushback</code> will not consume any further elements. <code>iter_without_pushback</code> will not make more than <code>max_iterations_per_job</code> calls to <code>f</code> in a single Async_job; this can be used to increase Async-scheduling fairness.</p></div></div><div><div class="spec value" id="val-transfer'" class="anchored"><a href="#val-transfer'" class="anchor"></a><code><span class="keyword">val</span> transfer' : <span>?&#8288;max_queue_length:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="Writer/index.html#type-t">Writer.t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span><span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Queue/index.html#type-t">Core_kernel.Queue.t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> <a href="../../../core_kernel/Core_kernel/Queue/index.html#type-t">Core_kernel.Queue.t</a></span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span>)</span></span> <span>&#45;&gt;</span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>transfer' input output ~f</code> repeatedly reads a batch of elements from <code>input</code>, applies <code>f</code> to the batch, writes the result as a batch to <code>output</code>, and then waits on <code>pushback</code> in <code>output</code> before continuing. <code>transfer'</code> finishes if <code>input</code> is closed or <code>output</code> is closed. If <code>output</code> is closed, then <code>transfer'</code> closes <code>input</code>. Use <code>~max_queue_length:1</code> to cause elements to appear on the output pipe as soon as they are processed, without having to wait for the entire queue.</p></div></div><div><div class="spec value" id="val-transfer" class="anchored"><a href="#val-transfer" class="anchor"></a><code><span class="keyword">val</span> transfer : <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="Writer/index.html#type-t">Writer.t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>transfer</code> is like <code>transfer'</code>, except that it processes one element at a time.</p></div></div><div><div class="spec value" id="val-transfer_id" class="anchored"><a href="#val-transfer_id" class="anchor"></a><code><span class="keyword">val</span> transfer_id : <span>?&#8288;max_queue_length:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Writer/index.html#type-t">Writer.t</a></span> <span>&#45;&gt;</span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>transfer_id</code> is a specialization of <code>transfer'</code> with <code>f = Fn.id</code>.</p></div></div><div><div class="spec value" id="val-map'" class="anchored"><a href="#val-map'" class="anchor"></a><code><span class="keyword">val</span> map' : <span>?&#8288;max_queue_length:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span><span class="type-var">'a</span> <a href="../../../core_kernel/Core_kernel/Queue/index.html#type-t">Core_kernel.Queue.t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> <a href="../../../core_kernel/Core_kernel/Queue/index.html#type-t">Core_kernel.Queue.t</a></span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><p><code>map' input ~f</code> returns a reader, <code>output</code>, and repeatedly applies <code>f</code> to batches of elements from <code>input</code>, with the results appearing in <code>output</code>. If values are not being consumed from <code>output</code>, <code>map'</code> will pushback and stop consuming values from <code>input</code>. If <code>output</code> is closed, then <code>map'</code> will close <code>input</code>. Use <code>~max_queue_length:1</code> to cause elements to appear on the output pipe as soon as they are processed, without having to wait for the entire queue.</p></div></div><div><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><p><code>map</code> is like <code>map'</code>, except that it processes one element at a time.</p></div></div><div><div class="spec value" id="val-folding_map" class="anchored"><a href="#val-folding_map" class="anchor"></a><code><span class="keyword">val</span> folding_map : <span>?&#8288;max_queue_length:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'accum</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'accum</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'accum</span> * <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><p><code>folding_map</code> is a version of <code>map</code> that threads an accumulator through calls to <code>f</code>.</p></div></div><div class="spec value" id="val-fold_map" class="anchored"><a href="#val-fold_map" class="anchor"></a><code><span class="keyword">val</span> fold_map : <span>?&#8288;max_queue_length:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'accum</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'accum</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'accum</span> * <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><div class="spec value" id="val-filter_map'" class="anchored"><a href="#val-filter_map'" class="anchor"></a><code><span class="keyword">val</span> filter_map' : <span>?&#8288;max_queue_length:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'b</span> option</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><p><code>filter_map' input ~f</code> returns a reader, <code>output</code>, and repeatedly applies <code>f</code> to elements from <code>input</code>, with the results that aren't <code>None</code> appearing in <code>output</code>. If values are not being consumed from <code>output</code>, <code>filter_map'</code> will pushback and stop consuming values from <code>input</code>. If <code>output</code> is closed, then <code>filter_map'</code> will close <code>input</code>. <code>filter_map'</code> processes elements in batches as per <code>max_queue_length</code>; in a single batch, all outputs will propagate to the result only when all inputs have been processed.</p></div></div><div><div class="spec value" id="val-filter_map" class="anchored"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : <span>?&#8288;max_queue_length:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><p><code>filter_map</code> is a specialized version of <code>filter_map'</code>.</p></div></div><div><div class="spec value" id="val-folding_filter_map" class="anchored"><a href="#val-folding_filter_map" class="anchor"></a><code><span class="keyword">val</span> folding_filter_map : <span>?&#8288;max_queue_length:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'accum</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'accum</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'accum</span> * <span><span class="type-var">'b</span> option</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><p><code>folding_filter_map</code> is a version <code>filter_map</code> that threads an accumulator through calls to <code>f</code>.</p></div></div><div class="spec value" id="val-fold_filter_map" class="anchored"><a href="#val-fold_filter_map" class="anchor"></a><code><span class="keyword">val</span> fold_filter_map : <span>?&#8288;max_queue_length:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'accum</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'accum</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'accum</span> * <span><span class="type-var">'b</span> option</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><div class="spec value" id="val-filter" class="anchored"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><p><code>filter input ~f</code> returns a reader, <code>output</code>, and copies to <code>output</code> each element from <code>input</code> that satisfies the predicate <code>f</code>. If <code>output</code> is closed, then <code>filter</code> closes <code>input</code>.</p></div></div><div><div class="spec value" id="val-interleave" class="anchored"><a href="#val-interleave" class="anchor"></a><code><span class="keyword">val</span> interleave : <span><span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><p><code>interleave inputs</code> returns a reader, <code>output</code>, and, for each input, transfers batches of values from that input to <code>output</code>, using <code>transfer_id</code>. Each input is transferred to <code>output</code> independently. So, batches of values from different inputs can be in flight to <code>output</code> simultaneously, but at most one batch at a time from any particular input. The operation is complete when either all the <code>inputs</code> produce EOF, or when <code>output</code> is closed by the downstream consumer (in which case <code>interleave</code> closes all the <code>inputs</code>).</p></div></div><div class="spec value" id="val-interleave_pipe" class="anchored"><a href="#val-interleave_pipe" class="anchor"></a><code><span class="keyword">val</span> interleave_pipe : <span><span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><div class="spec value" id="val-merge" class="anchored"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val</span> merge : <span><span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> list</span> <span>&#45;&gt;</span> <span>compare:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><p><code>merge inputs ~compare</code> returns a reader, <code>output</code>, that merges all the inputs. Assuming that for each input, values are sorted according to the comparison function <code>compare</code>, values for each input will be transfered to <code>output</code> and the values returned by <code>output</code> will be sorted according to <code>compare</code>.</p></div></div><div><div class="spec value" id="val-concat" class="anchored"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span><span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><p><code>concat inputs</code> return a reader, <code>output</code>, with the values from each pipe in <code>inputs</code> in sequence. <code>concat</code> closes <code>output</code> once it reaches EOF on the final input. If <code>output</code> is closed, then <code>concat</code> closes all its inputs.</p></div></div><div><div class="spec value" id="val-fork" class="anchored"><a href="#val-fork" class="anchor"></a><code><span class="keyword">val</span> fork : <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>pushback_uses:<span>[ `Both_consumers <span>| `Fast_consumer_only</span> ]</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> * <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><p><code>fork input</code> returns a pair of readers and transfers each of the values in <code>input</code> into both of the returned readers. It closes <code>input</code> early if both of the readers are closed early.</p><p>If <code>pushback_uses = `Both_consumers</code>, then <code>fork</code> waits for <code>pushback</code> on both readers when writing. If one of the readers is not read from or is slow to be read from, it may block the other from receiving data. Beware of possible deadlocks in downstream code due to blocking on reading too many elements from one before reading the other.</p><p>If <code>pushback_uses = `Fast_consumer_only</code>, then <code>fork</code> waits for <code>pushback</code> only on the faster of the two readers when writing. In this case the slow reader cannot block the faster one, but <code>fork</code> could be forced to buffer arbitrarily many elements. Beware of unbounded resource usage in downstream code where one reader might fall behind.</p><p>Note that <a href="index.html#val-upstream_flushed"><code>upstream_flushed</code></a> will not work with the pipes returned by <code>fork</code>.</p></div></div><div><div class="spec value" id="val-to_stream_deprecated" class="anchored"><a href="#val-to_stream_deprecated" class="anchor"></a><code><span class="keyword">val</span> to_stream_deprecated : <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Tail/Stream/index.html#type-t">Tail.Stream.t</a></span></code></div><div><p><code>to_stream_deprecated reader</code> returns a stream that reads everything from the pipe. This function is deprecated because one should change the code that is consuming a stream to instead consume from a pipe reader.</p></div></div><div><div class="spec value" id="val-of_stream_deprecated" class="anchored"><a href="#val-of_stream_deprecated" class="anchor"></a><code><span class="keyword">val</span> of_stream_deprecated : <span><span class="type-var">'a</span> <a href="../Tail/Stream/index.html#type-t">Tail.Stream.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span></code></div><div><p><code>of_stream_deprecated reader</code> returns a pipe that has one element for every element on the stream. This function is deprecated because one should change the code that is producing a stream to instead produce a pipe reader.</p></div></div><div><div class="spec value" id="val-drain" class="anchored"><a href="#val-drain" class="anchor"></a><code><span class="keyword">val</span> drain : <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>unit <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>drain reader</code> repeatedly reads values from <code>reader</code> and throws them away.</p><p><code>drain_and_count</code> is like <code>drain</code>, except it also counts the number of values it has read.</p></div></div><div class="spec value" id="val-drain_and_count" class="anchored"><a href="#val-drain_and_count" class="anchor"></a><code><span class="keyword">val</span> drain_and_count : <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span>int <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><div class="spec value" id="val-to_list" class="anchored"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <span><span class="type-var">'a</span> <a href="Reader/index.html#type-t">Reader.t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="../Deferred/index.html#type-t">Deferred.t</a></span></code></div><div><p><code>to_list input</code> reads everything from <code>input</code>; on EOF, it produces the accumulated list of these values.</p></div></div><h3 id="miscellaneous"><a href="#miscellaneous" class="anchor"></a>Miscellaneous</h3><div><div class="spec value" id="val-hash" class="anchored"><a href="#val-hash" class="anchor"></a><code><span class="keyword">val</span> hash : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></div><div><p><code>hash</code> is a hash function based on the internal id of the pipe.</p></div></div><div><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></div><div><p><code>equal</code> on pipes is physical equality.</p></div></div><div><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></div><div><p><code>compare</code> on pipes is based on the internal id of the pipe.</p></div></div><h3 id="size-budget"><a href="#size-budget" class="anchor"></a>Size budget</h3><div><div class="spec value" id="val-size_budget" class="anchored"><a href="#val-size_budget" class="anchor"></a><code><span class="keyword">val</span> size_budget : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></div><div><p>Every pipe has a &quot;size budget&quot;, which governs the pushback that is used to discourage writers from enqueueing arbitrarily large amounts of data. As long as the length of the pipe exceeds the size budget, writers will not be notified to do further writing. Whenever the length is less than or equal to the size budget, writers will be notified to continue.</p><p>Every pipe's initial size budget is zero.</p></div></div><div><div class="spec value" id="val-set_size_budget" class="anchored"><a href="#val-set_size_budget" class="anchor"></a><code><span class="keyword">val</span> set_size_budget : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></div><div><p><code>set_size_budget t i</code> changes the size budget of <code>t</code> to <code>i</code>. Any nonnegative value is allowed.</p></div></div><h3 id="debugging"><a href="#debugging" class="anchor"></a>Debugging</h3><div><div class="spec value" id="val-show_debug_messages" class="anchored"><a href="#val-show_debug_messages" class="anchor"></a><code><span class="keyword">val</span> show_debug_messages : <span>bool <a href="../../../core_kernel/Core_kernel/index.html#type-ref">Core_kernel.ref</a></span></code></div><div><p><code>show_debug_messages</code>, if true, will cause a message to be printed at the start of each operation, showing the pipe and other arguments.</p></div></div><div><div class="spec value" id="val-check_invariant" class="anchored"><a href="#val-check_invariant" class="anchor"></a><code><span class="keyword">val</span> check_invariant : <span>bool <a href="../../../core_kernel/Core_kernel/index.html#type-ref">Core_kernel.ref</a></span></code></div><div><p><code>check_invariant</code>, if true, will cause pipes' invariants to be checked at the start of each operation.</p></div></div></div></body></html>