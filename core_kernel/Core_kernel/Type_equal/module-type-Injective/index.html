<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Injective (core_kernel.Core_kernel.Type_equal.Injective)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> – <a href="../../../index.html">core_kernel</a> &#x00BB; <a href="../../index.html">Core_kernel</a> &#x00BB; <a href="../index.html">Type_equal</a> &#x00BB; Injective</nav><header><h1>Module type <code>Type_equal.Injective</code></h1><p><code>Injective</code> is an interface that states that a type is injective, where the type is viewed as a function from types to other types. The typical usage is:</p><pre><code>type 'a t
include Injective with type 'a t := 'a t</code></pre><p>For example, <code>'a list</code> is an injective type, because whenever <code>'a list = 'b list</code>, we know that <code>'a</code> = <code>'b</code>. On the other hand, if we define:</p><pre><code>type 'a t = unit</code></pre><p>then clearly <code>t</code> isn't injective, because, e.g., <code>int t = bool t</code>, but <code>int &lt;&gt; bool</code>.</p><p>If <code>module M : Injective</code>, then <code>M.strip</code> provides a way to get a proof that two types are equal from a proof that both types transformed by <code>M.t</code> are equal.</p><p>OCaml has no built-in language feature to state that a type is injective, which is why we have <code>module type Injective</code>. However, OCaml can infer that a type is injective, and we can use this to match <code>Injective</code>. A typical implementation will look like this:</p><pre><code>let strip (type a) (type b)
      (Type_equal.T : (a t, b t) Type_equal.t) : (a, b) Type_equal.t =
  Type_equal.T</code></pre><p>This will not type check for all type constructors (certainly not for non-injective ones!), but it's always safe to try the above implementation if you are unsure. If OCaml accepts this definition, then the type is injective. On the other hand, if OCaml doesn't, then the type may or may not be injective. For example, if the definition of the type depends on abstract types that match <code>Injective</code>, OCaml will not automatically use their injectivity, and one will have to write a more complicated definition of <code>strip</code> that causes OCaml to use that fact. For example:</p><pre><code>module F (M : Type_equal.Injective) : Type_equal.Injective = struct
  type 'a t = 'a M.t * int

  let strip (type a) (type b)
        (e : (a t, b t) Type_equal.t) : (a, b) Type_equal.t =
    let e1, _ = Type_equal.detuple2 e in
    M.strip e1
  ;;
end</code></pre><p>If in the definition of <code>F</code> we had written the simpler implementation of <code>strip</code> that didn't use <code>M.strip</code>, then OCaml would have reported a type error.</p></header><div class="content"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></div><div class="spec value" id="val-strip" class="anchored"><a href="#val-strip" class="anchor"></a><code><span class="keyword">val</span> strip : <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>, <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <a href="../index.html#type-equal">equal</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../index.html#type-equal">equal</a></span></code></div></div></body></html>