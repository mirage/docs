<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Escaping (base.Base.String.Escaping)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">base</a> &#x00BB; <a href="../../index.html">Base</a> &#x00BB; <a href="../index.html">String</a> &#x00BB; Escaping</nav><header><h1>Module <code>String.Escaping</code></h1><p>Operations for escaping and unescaping strings, with parameterized escape and escapeworthy characters. Escaping/unescaping using this module is more efficient than using Pcre. Benchmark code can be found in core/benchmarks/string_escaping.ml.</p></header><div class="content"><div><div class="spec value" id="val-escape_gen_exn" class="anchored"><a href="#val-escape_gen_exn" class="anchor"></a><code><span class="keyword">val</span> escape_gen_exn : <span>escapeworthy_map:<span><span>(char * char)</span> list</span></span> <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> <span><span>(string <span>&#45;&gt;</span> string)</span> <a href="../../Staged/index.html#type-t">Staged.t</a></span></code></div><div><p><code>escape_gen_exn escapeworthy_map escape_char</code> returns a function that will escape a string <code>s</code> as follows: if <code>(c1,c2)</code> is in <code>escapeworthy_map</code>, then all occurrences of <code>c1</code> are replaced by <code>escape_char</code> concatenated to <code>c2</code>.</p><p>Raises an exception if <code>escapeworthy_map</code> is not one-to-one. If <code>escape_char</code> is not in <code>escapeworthy_map</code>, then it will be escaped to itself.</p></div></div><div class="spec value" id="val-escape_gen" class="anchored"><a href="#val-escape_gen" class="anchor"></a><code><span class="keyword">val</span> escape_gen : <span>escapeworthy_map:<span><span>(char * char)</span> list</span></span> <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> <span><span>(string <span>&#45;&gt;</span> string)</span> <a href="../../Or_error/index.html#type-t">Or_error.t</a></span></code></div><div><div class="spec value" id="val-escape" class="anchored"><a href="#val-escape" class="anchor"></a><code><span class="keyword">val</span> escape : <span>escapeworthy:<span>char list</span></span> <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> <span><span>(string <span>&#45;&gt;</span> string)</span> <a href="../../Staged/index.html#type-t">Staged.t</a></span></code></div><div><p><code>escape ~escapeworthy ~escape_char s</code> is</p><pre><code>escape_gen_exn ~escapeworthy_map:(List.zip_exn escapeworthy escapeworthy)
  ~escape_char</code></pre><p>Duplicates and <code>escape_char</code> will be removed from <code>escapeworthy</code>. So, no exception will be raised</p></div></div><div><div class="spec value" id="val-unescape_gen_exn" class="anchored"><a href="#val-unescape_gen_exn" class="anchor"></a><code><span class="keyword">val</span> unescape_gen_exn : <span>escapeworthy_map:<span><span>(char * char)</span> list</span></span> <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> <span><span>(string <span>&#45;&gt;</span> string)</span> <a href="../../Staged/index.html#type-t">Staged.t</a></span></code></div><div><p><code>unescape_gen_exn</code> is the inverse operation of <code>escape_gen_exn</code>. That is,</p><pre><code>let escape = Staged.unstage (escape_gen_exn ~escapeworthy_map ~escape_char) in
let unescape = Staged.unstage (unescape_gen_exn ~escapeworthy_map ~escape_char) in
assert (s = unescape (escape s))</code></pre><p>always succeed when ~escapeworthy_map is not causing exceptions.</p></div></div><div class="spec value" id="val-unescape_gen" class="anchored"><a href="#val-unescape_gen" class="anchor"></a><code><span class="keyword">val</span> unescape_gen : <span>escapeworthy_map:<span><span>(char * char)</span> list</span></span> <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> <span><span>(string <span>&#45;&gt;</span> string)</span> <a href="../../Or_error/index.html#type-t">Or_error.t</a></span></code></div><div><div class="spec value" id="val-unescape" class="anchored"><a href="#val-unescape" class="anchor"></a><code><span class="keyword">val</span> unescape : <span>escape_char:char</span> <span>&#45;&gt;</span> <span><span>(string <span>&#45;&gt;</span> string)</span> <a href="../../Staged/index.html#type-t">Staged.t</a></span></code></div><div><p><code>unescape ~escape_char</code> is defined as <code>unescape_gen_exn ~map:[] ~escape_char</code></p></div></div><div><div class="spec value" id="val-is_char_escaping" class="anchored"><a href="#val-is_char_escaping" class="anchor"></a><code><span class="keyword">val</span> is_char_escaping : string <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool</code></div><div><p>Any char in an escaped string is either escaping, escaped, or literal. For example, for escaped string <code>&quot;0_a0__0&quot;</code> with <code>escape_char</code> as <code>'_'</code>, pos 1 and 4 are escaping, 2 and 5 are escaped, and the rest are literal.</p><p><code>is_char_escaping s ~escape_char pos</code> returns true if the char at <code>pos</code> is escaping, false otherwise.</p></div></div><div><div class="spec value" id="val-is_char_escaped" class="anchored"><a href="#val-is_char_escaped" class="anchor"></a><code><span class="keyword">val</span> is_char_escaped : string <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool</code></div><div><p><code>is_char_escaped s ~escape_char pos</code> returns true if the char at <code>pos</code> is escaped, false otherwise.</p></div></div><div><div class="spec value" id="val-is_char_literal" class="anchored"><a href="#val-is_char_literal" class="anchor"></a><code><span class="keyword">val</span> is_char_literal : string <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool</code></div><div><p><code>is_char_literal s ~escape_char pos</code> returns true if the char at <code>pos</code> is not escaped or escaping.</p></div></div><div><div class="spec value" id="val-index" class="anchored"><a href="#val-index" class="anchor"></a><code><span class="keyword">val</span> index : string <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <span>int option</span></code></div><div><p><code>index s ~escape_char char</code> finds the first literal (not escaped) instance of <code>char</code> in s starting from 0.</p></div></div><div class="spec value" id="val-index_exn" class="anchored"><a href="#val-index_exn" class="anchor"></a><code><span class="keyword">val</span> index_exn : string <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int</code></div><div><div class="spec value" id="val-rindex" class="anchored"><a href="#val-rindex" class="anchor"></a><code><span class="keyword">val</span> rindex : string <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <span>int option</span></code></div><div><p><code>rindex s ~escape_char char</code> finds the first literal (not escaped) instance of <code>char</code> in <code>s</code> starting from the end of <code>s</code> and proceeding towards 0.</p></div></div><div class="spec value" id="val-rindex_exn" class="anchored"><a href="#val-rindex_exn" class="anchor"></a><code><span class="keyword">val</span> rindex_exn : string <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int</code></div><div><div class="spec value" id="val-index_from" class="anchored"><a href="#val-index_from" class="anchor"></a><code><span class="keyword">val</span> index_from : string <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <span>int option</span></code></div><div><p><code>index_from s ~escape_char pos char</code> finds the first literal (not escaped) instance of <code>char</code> in <code>s</code> starting from <code>pos</code> and proceeding towards the end of <code>s</code>.</p></div></div><div class="spec value" id="val-index_from_exn" class="anchored"><a href="#val-index_from_exn" class="anchor"></a><code><span class="keyword">val</span> index_from_exn : string <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int</code></div><div><div class="spec value" id="val-rindex_from" class="anchored"><a href="#val-rindex_from" class="anchor"></a><code><span class="keyword">val</span> rindex_from : string <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <span>int option</span></code></div><div><p><code>rindex_from s ~escape_char pos char</code> finds the first literal (not escaped) instance of <code>char</code> in <code>s</code> starting from <code>pos</code> and towards 0.</p></div></div><div class="spec value" id="val-rindex_from_exn" class="anchored"><a href="#val-rindex_from_exn" class="anchor"></a><code><span class="keyword">val</span> rindex_from_exn : string <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int</code></div><div><div class="spec value" id="val-split" class="anchored"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : string <span>&#45;&gt;</span> <span>on:char</span> <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> <span>string list</span></code></div><div><p><code>split s ~escape_char ~on</code> returns a list of substrings of <code>s</code> that are separated by literal versions of <code>on</code>. Consecutive <code>on</code> characters will cause multiple empty strings in the result. Splitting the empty string returns a list of the empty string, not the empty list.</p><p>E.g., <code>split ~escape_char:'_' ~on:',' &quot;foo,bar_,baz&quot; = [&quot;foo&quot;; &quot;bar_,baz&quot;]</code>.</p></div></div><div><div class="spec value" id="val-split_on_chars" class="anchored"><a href="#val-split_on_chars" class="anchor"></a><code><span class="keyword">val</span> split_on_chars : string <span>&#45;&gt;</span> <span>on:<span>char list</span></span> <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> <span>string list</span></code></div><div><p><code>split_on_chars s ~on</code> returns a list of all substrings of <code>s</code> that are separated by one of the literal chars from <code>on</code>. <code>on</code> are not grouped. So a grouping of <code>on</code> in the source string will produce multiple empty string splits in the result.</p><p>E.g., <code>split_on_chars ~escape_char:'_' ~on:[',';'|'] &quot;foo_|bar,baz|0&quot; -&gt;
      [&quot;foo_|bar&quot;; &quot;baz&quot;; &quot;0&quot;]</code>.</p></div></div><div><div class="spec value" id="val-lsplit2" class="anchored"><a href="#val-lsplit2" class="anchor"></a><code><span class="keyword">val</span> lsplit2 : string <span>&#45;&gt;</span> <span>on:char</span> <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> <span><span>(string * string)</span> option</span></code></div><div><p><code>lsplit2 s ~on ~escape_char</code> splits s into a pair on the first literal instance of <code>on</code> (meaning the first unescaped instance) starting from the left.</p></div></div><div class="spec value" id="val-lsplit2_exn" class="anchored"><a href="#val-lsplit2_exn" class="anchor"></a><code><span class="keyword">val</span> lsplit2_exn : string <span>&#45;&gt;</span> <span>on:char</span> <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> string * string</code></div><div><div class="spec value" id="val-rsplit2" class="anchored"><a href="#val-rsplit2" class="anchor"></a><code><span class="keyword">val</span> rsplit2 : string <span>&#45;&gt;</span> <span>on:char</span> <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> <span><span>(string * string)</span> option</span></code></div><div><p><code>rsplit2 s ~on ~escape_char</code> splits <code>s</code> into a pair on the first literal instance of <code>on</code> (meaning the first unescaped instance) starting from the right.</p></div></div><div class="spec value" id="val-rsplit2_exn" class="anchored"><a href="#val-rsplit2_exn" class="anchor"></a><code><span class="keyword">val</span> rsplit2_exn : string <span>&#45;&gt;</span> <span>on:char</span> <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> string * string</code></div><div><div class="spec value" id="val-lstrip_literal" class="anchored"><a href="#val-lstrip_literal" class="anchor"></a><code><span class="keyword">val</span> lstrip_literal : <span>?&#8288;drop:<span>(char <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a> <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a></code></div><div><p>These are the same as <code>lstrip</code>, <code>rstrip</code>, and <code>strip</code> for generic strings, except that they only drop literal characters -- they do not drop characters that are escaping or escaped. This makes sense if you're trying to get rid of junk whitespace (for example), because escaped whitespace seems more likely to be deliberate and not junk.</p></div></div><div class="spec value" id="val-rstrip_literal" class="anchored"><a href="#val-rstrip_literal" class="anchor"></a><code><span class="keyword">val</span> rstrip_literal : <span>?&#8288;drop:<span>(char <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a> <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a></code></div><div class="spec value" id="val-strip_literal" class="anchored"><a href="#val-strip_literal" class="anchor"></a><code><span class="keyword">val</span> strip_literal : <span>?&#8288;drop:<span>(char <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a> <span>&#45;&gt;</span> <span>escape_char:char</span> <span>&#45;&gt;</span> <a href="../index.html#type-t">t</a></code></div></div></body></html>