<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>odoc-internals (odoc.odoc-internals)</title><link rel="stylesheet" href="../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="index.html">Up</a> â€“ <a href="index.html">odoc</a> &#x00BB; odoc-internals</nav><header><h1 id="top"><a href="#top" class="anchor"></a>Understanding odoc Internals</h1><p>This manual page describes the constituents of the compilation process and their relationships in the different compilation phases.</p><ol><li><a href="#constituents">Constituents</a></li><li><a href="#phases">Compilation Phases</a></li></ol></header><nav class="toc"><ul><li><a href="#constituents">Constituents</a></li><li><a href="#phases">Compilation Phases</a><ul><li><a href="#prepping-phase">Prepping</a></li><li><a href="#loading-phase">Loading</a></li><li><a href="#xref-phase">Cross Referencing</a></li><li><a href="#tree-phase">Tree Building</a></li><li><a href="#printing-phase">Printing</a></li></ul></li></ul></nav><div class="content"><h2 id="constituents"><a href="#constituents" class="anchor"></a>Constituents</h2><p>...</p><h2 id="phases"><a href="#phases" class="anchor"></a>Compilation Phases</h2><p>Whenever <code>odoc</code> attempts to compile a new <code>.odoc</code> file from a compiler output, it will go through 3 distinct compilation phases:</p><ol><li>Prepping,</li><li>Loading, and</li><li>Cross-referencing</li></ol><p>In the case of HTML generation, an additional 2 phases happen:</p><ol><li>Tree building, and</li><li>Printing.</li></ol><h3 id="prepping-phase"><a href="#prepping-phase" class="anchor"></a>Prepping</h3><p>Every compilation step will begin by building an <a href="../ocaml/Env/index.html#type-t"><code>Env.t</code></a> (environment) by looking into the import directories (specified with <code>-I</code>), and acquiring a <code>File</code>.t file descriptor to the input file. This will make all of the compilation units compiled earlier, available to the current one.</p><p>Output directories will be made sure exist and are writeable too.</p><p>Once this is all done, dispatching based on the file extension will happen and <a href="#loading-phase">loading will begin</a>.</p><h3 id="loading-phase"><a href="#loading-phase" class="anchor"></a>Loading</h3><p>It always begins by creating a <a href="../odoc/Odoc_model/Root/Odoc_file/index.html#type-t"><code>Odoc_model.Root.Odoc_file.t</code></a> file representation. This happens equally for all formats, including <code>.mld</code> files where <a href="../odoc/Odoc_model/Root/Odoc_file/index.html#val-create_page"><code>Odoc_model.Root.Odoc_file.create_page</code></a> is used.</p><p>This representation specifies whether we are about to compile a <code>Page</code> or if we in fact have an OCaml <a href="../ocaml/Compilation_unit/index.html"><code>Compilation_unit</code></a>. It will be used to create a broader record of type <a href="../odoc/Odoc_model/Root/index.html#type-t"><code>Odoc_model.Root.t</code></a>, that will contain all the information relevant to our current document.</p><p>For <code>.cmt(i)</code> files, however, this record isn't yet created. We will come by it as soon as a module name and a <i>digest</i> are read. The process then continues and <a href="../odoc/Odoc_loader/index.html#val-read_cmti"><code>Odoc_loader.read_cmti</code></a> will attempt to read this file, accessing the <i>digest</i>, creating the <a href="../odoc/Odoc_model/Root/index.html#type-t"><code>Odoc_model.Root.t</code></a>, and, subsequently, when the <code>.cmti</code> typed tree is read and parsed, building a <a href="../ocaml/Compilation_unit/index.html#type-t"><code>Compilation_unit.t</code></a>.</p><p>While building the <a href="../ocaml/Compilation_unit/index.html#type-t"><code>Compilation_unit.t</code></a>, the <code>.cmti</code> file will be read into a <a href="../ocaml/Cmt_format/index.html#type-cmt_infos"><code>Cmt_format.cmt_infos</code></a> value using the OCaml library <a href="../ocaml/Cmt_format/index.html"><code>Cmt_format</code></a>. This could end up in a few error cases, but if we don't catch any exceptions on our way, we will get a value of <a href="../ocaml/Cmt_format/index.html#type-binary_annots"><code>Cmt_format.binary_annots</code></a> (binary annotations) indicating whether this file is indeed an <code>Interface</code> or some other thing (a <code>Packed</code> module, an <code>Implementation</code>, a <code>Partial_implementation</code>, or even a <code>Partial_interface</code>).</p><p>Given that we do have an <code>Interface</code>, we can extract its module name, the list of modules that need to be imported (and tag them as Unresolved), and finally build <a href="../ocaml/Compilation_unit/index.html#type-t"><code>Compilation_unit.t</code></a> out of them. This list will be important later on, as we attempt to <a href="#xref-phase">resolve all references</a>.</p><h3 id="xref-phase"><a href="#xref-phase" class="anchor"></a>Cross Referencing</h3><p>Now that we have a brand new compilation unit, we need to make sure that the things it references (such as functions or types in other modules) are properly resolved.</p><p>To do this, we will begin by making a <i>lookup</i>. This will create a new <code>Lookup</code>.lookup object, and use our current compilation unit to grow its name environment (<code>Name_env</code>.t) by adding whatever new signatures we've defined in the current module.</p><p>Immediately after, we will attempt to build a <i>resolving environment</i> (of type <a href="../ocaml/Env/index.html#type-t"><code>Env.t</code></a>). This environment will then be used to resolve this modlule's references in <code>Odoc_xref</code>.resolve.</p><p>This process occurs two times! For legacy reasons, we need to repeat this twice, the second time with the result of the first. Then we can proceed to <i>expand</i> these references, which we can use for saving our <code>.odoc</code> file.</p><p>We expand the cross-referencing environment one more time, and hand it over to <code>Compilation_unit</code>.save so it will be marshalled and saved.</p><h3 id="tree-phase"><a href="#tree-phase" class="anchor"></a>Tree Building</h3><p>In case we are compiling an <code>.odoc</code> file to <code>.html</code>, we will continue the process after cross-referencing by delegating to one of the <code>To_html_tree</code> modules. If the HTML is to have Reason syntax, <code>Odoc_html</code>.To_html_tree.RE will be used, otherwise <code>Odoc_html</code>.To_html_tree.ML.</p><p><code>TODO(@ostera): explain how Odoc_html.To_html_tree.ML.compilation_unit works</code></p><h3 id="printing-phase"><a href="#printing-phase" class="anchor"></a>Printing</h3><p>After the HTML tree is fully built, we can just ask <a href="../tyxml/Tyxml_html/index.html"><code>Tyxml.Html</code></a> to print it into a string for us. So folders will be created to make sure the output can be written, and then for each page and compilation unit an <code>.html</code> file will be created and written to.</p><p>That's pretty much all there is to printing.</p></div></body></html>