<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>high-level-flow (odoc.high-level-flow)</title><link rel="stylesheet" href="../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="index.html">Up</a> – <a href="index.html">odoc</a> &#x00BB; high-level-flow</nav><header><h1 id="top"><a href="#top" class="anchor"></a>Hows does <code>odoc</code> work?</h1><p><code>odoc</code> is built in a very modular fashion, with several modules that take care of mostly orthogonal concerns.</p><p>Instead of namedropping them, we will describe a use-case and how they connect to each other as we analyze its execution superficially.</p><p>We will begin the flow with an <code>odoc</code> command that compiles a single <code>cmti</code> file, <code>Player.cmti</code>, into its corresponding <code>html</code> file. Then we will compile the <code>intro.mld</code> documentation file into html.</p><ol><li><a href="#step-1">Compiling Player.cmti to Player.odoc</a></li><li><a href="#step-2">Compiling Player.odoc to Player/index.html</a></li><li><a href="#step-3">Compiling intro.mld to page-intro.odoc</a></li><li><a href="#step-4">Compiling page-intro.odoc to intro.html</a></li></ol><p>Off we go!</p></header><nav class="toc"><ul><li><a href="#step-1">1 — Compiling Player.cmti to Player.odoc</a></li><li><a href="#step-2">2 — Compiling Player.odoc to Player/index.html</a></li><li><a href="#step-3">3 — Compiling page-intro.mld to page-intro.odoc</a></li><li><a href="#step-4">4 — Compiling page-intro.odoc to intro.html</a></li></ul></nav><div class="content"><h4 id="step-1"><a href="#step-1" class="anchor"></a>1 — Compiling Player.cmti to Player.odoc</h4><p>Superficially, what we need to do is straighforward.</p><pre><code># We must tell odoc what the name of this Package is!
$ odoc compile --package Game -o ./src/Player.odoc ./src/Player.cmti
$ ls src
Player.cmti Player.mli Player.odoc</code></pre><p>Voila! We get a <code>Player.odoc</code> right where we expected it. But what really just happened?</p><ol><li>In <a href="../ocaml/Main/index.html"><code>Main</code></a> the command was parsed and a decision was made to <i>compile</i> this file into an <code>odoc</code> file</li><li>Compilation is orchestrated by <code>Main</code>.Compile.compile, that based on the input extension will delegate to one of many <a href="../ocaml/Compile/index.html"><code>Compile</code></a> functions. In this case <code>Compile</code>.cmti</li><li>The <code>cmti</code> file is read by <a href="../odoc/Odoc_loader/index.html#val-read_cmti"><code>Odoc_loader.read_cmti</code></a> into a <a href="../odoc/Odoc_model/Root/index.html#type-t"><code>Odoc_model.Root.t</code></a> and a <a href="../ocaml/Compilation_unit/index.html#type-t"><code>Compilation_unit.t</code></a> is created</li><li>This compilation unit is then turned into an <a href="../ocaml/Env/index.html#type-t"><code>Env.t</code></a> (environment), expanding all found references between modules</li><li>And lastly <code>Compilation_unit</code>.save takes care of saving this compilation unit into the <code>Player.odoc</code> file in marshalled format.</li></ol><h4 id="step-2"><a href="#step-2" class="anchor"></a>2 — Compiling Player.odoc to Player/index.html</h4><p>Now we can compile this to an HTML file:</p><pre><code>$ odoc html -I src -o . ./src/Player.odoc
$ cat Game/Player/index.html
# mangled html output here!</code></pre><p>In this case, what happened was</p><ol><li>In <a href="../ocaml/Main/index.html"><code>Main</code></a> the command is parsed as well, and it decides to <i>compile</i> the input into an <code>html</code> file.</li><li>Compilation is orchestrated by <code>Main</code>.Odoc_html.html, that will make sure some global flags are set up (depending on command flags), and delegate to <code>Html_page</code>.from_odoc</li><li>The <code>odoc</code> file is read into a <a href="../odoc/Odoc_model/Root/index.html#type-t"><code>Odoc_model.Root.t</code></a></li><li>Since it contains a <a href="../odoc/Odoc_model/Root/Odoc_file/index.html#type-t.Compilation_unit"><code>Odoc_model.Root.Odoc_file.t.Compilation_unit</code></a>, an <a href="../ocaml/Env/index.html#type-t"><code>Env.t</code></a> (environment) will be built, with its references expanded, just like in the first step</li><li>An <code>Odoc_html</code>.Html_tree.t will be built, depending on the syntax chosen (in this case the default is OCaml) by <code>Odoc_html</code>.To_html_tree.ML.compilation_unit</li><li>Lastly, this tree will be traversed, the <code>Game/Player</code> folder created, and the <code>index.html</code> file written to disk.</li></ol><h4 id="step-3"><a href="#step-3" class="anchor"></a>3 — Compiling page-intro.mld to page-intro.odoc</h4><p>We will begin by invoking <code>odoc</code> similarly than we did in the <a href="#step-1">first step</a>.</p><pre><code>$ odoc compile --package Game -o ./src/page-intro.odoc ./src/page-intro.mld
$ ls src
page-intro.mld page-intro.odoc</code></pre><ol><li>Again in <a href="../ocaml/Main/index.html"><code>Main</code></a> the command was parsed and a decision was made to <i>compile</i> this file into an <code>odoc</code> file</li><li>Compilation is orchestrated by <code>Main</code>.Compile.compile, and it delegates compilation to <code>Compile</code>.mld based on the extension of the input</li><li>A <a href="../odoc/Odoc_model/Lang/Page/index.html#type-t"><code>Odoc_model.Lang.Page.t</code></a> will be created from it, and an <a href="../ocaml/Env/index.html#type-t"><code>Env.t</code></a> will be built resolving found references</li><li>Lastly, the resulting page will be written down to disk by <code>Page</code>.save</li></ol><h4 id="step-4"><a href="#step-4" class="anchor"></a>4 — Compiling page-intro.odoc to intro.html</h4><pre><code>$ odoc html -I src -o . ./src/page-intro.odoc
$ cat Game/intro.html
# mangled html output here!</code></pre><p>This process is in fact almost the same as in <a href="#step-2">the last html compilation</a>. The main differences are that:</p><ol><li>the read <a href="../odoc/Odoc_model/Root/index.html#type-t"><code>Odoc_model.Root.t</code></a> contains a <a href="../odoc/Odoc_model/Root/Odoc_file/index.html#type-t.Page"><code>Odoc_model.Root.Odoc_file.t.Page</code></a> instead,</li><li>the output file name will drop the <code>page-</code> prefix,</li><li>the <code>Odoc_html</code>.Html_tree.t is built by <code>Odoc_html</code>.To_html_tree.ML.page</li></ol></div></body></html>