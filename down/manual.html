<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>manual (down.manual)</title><link rel="stylesheet" href="../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="index.html">Up</a> – <a href="index.html">down</a> &#x00BB; manual</nav><header><h1 id="down-manual"><a href="#down-manual" class="anchor"></a>Down manual</h1><p>Down is an unintrusive user experience upgrade for the <code>ocaml</code> toplevel (REPL).</p></header><nav class="toc"><ul><li><a href="#setup">Setup</a></li><li><a href="#line_edition">Line edition</a></li><li><a href="#history">History</a></li><li><a href="#sessions">Sessions</a><ul><li><a href="#basic">Basics</a></li><li><a href="#recording">Recording phrases</a></li><li><a href="#stepping">Stepping phrases</a></li><li><a href="#data">Where is the data ?</a></li></ul></li><li><a href="#id_completion">Identifier completion and documentation</a></li></ul></nav><div class="content"><h2 id="setup"><a href="#setup" class="anchor"></a>Setup</h2><p>To use Down in <code>ocaml</code> simply issue this phrase:</p><pre><code># #use &quot;down.top&quot;   (* or &quot;down.nattop&quot; in ocamlnat *)</code></pre><p>You can add this line to your <code>~/.ocamlinit</code> file.</p><p>The impact of using <code>Down</code> on the toplevel environment should be minimal: it loads the library <code>down.cma</code>, makes the <a href="../down/Down/index.html">Down API</a> accessible by including its library directory, sets standard input in raw mode whenever it asks for user input and installs a signal handler for <code>SIGWINCH</code>.</p><p>This is it.</p><h2 id="line_edition"><a href="#line_edition" class="anchor"></a>Line edition</h2><p><code>Down</code> provides classical readline capability. There is not much to be said about it and should be mostly natural if you are used to command line interfaces. A summary of key bindings is available by invoking:</p><pre><code># Down.help ()   (* show key bindings and basic help *)</code></pre><p><code>Down</code> listens for keyboard input until you hit return and the input phrase ends with a trailing <code>;;</code> character sequence. At that point it gives it to <code>ocaml</code> for execution and gets back to you once it has an answer.</p><p>Unicode text is supported in a limited manner using a weak form of grapheme clusters based on the data of <code>Uucp</code>.Break.tty_width_hint. This should be good enough for basic REPL interaction. However it may fail (not too catastrophically) on some of UTF-8 encoded string literals – for example if they contain emoji skin tone modifiers.</p><p>The key bindings cannot be customized at the moment (see <a href="https://github.com/dbuenzli/down/issues/12">this issue</a>).</p><h2 id="history"><a href="#history" class="anchor"></a>History</h2><p>To navigate input history use the up and down arrows of your keyboard.</p><p>History is stored accross <code>ocaml</code> invocations in <code>~/.config/ocaml/history.ml</code>. This is a plain text file where history entries are separated by <code>(**)</code> lines. It may not be a syntactically valid OCaml file since history includes lines that did not parse.</p><p>The <a href="../down/Down/History/index.html"><code>Down.History</code></a> module has a few functions to manipulate history:</p><pre><code># Down.History.edit ()   (* edit the history in your editor *)
# Down.History.clear ()  (* clear your history *)</code></pre><h2 id="sessions"><a href="#sessions" class="anchor"></a>Sessions</h2><p>Sessions allow to record, edit, save and replay sequences of phrases. You can see them as named and executable histories or <code>#use</code>able files available via short and absolute names.</p><p>They are useful to quickly setup a given environment or to reliably insert a given sequence of phrases on the prompt if you are making a demonstration with the toplevel (see <span class="xref-unresolved">stepping</span>).</p><h3 id="basic"><a href="#basic" class="anchor"></a>Basics</h3><p>Session management is provided by the <a href="../down/Down/Session/index.html"><code>Down.Session</code></a> module. To list available sessions issue:</p><pre><code># Down.Session.list ()   (* list the names of available sessions *)</code></pre><p>There are different ways of creating sessions. One way of doing so is to call the <code>edit</code> function</p><pre><code># Down.Session.edit &quot;mysession&quot;   (* edit or create a session *)</code></pre><p>this opens an OCaml file named <code>mysession.ml</code> in your editor in which you can insert or modify OCaml toplevel phrases. Once you are done, you can <code>load</code> the session to execute its phrases:</p><pre><code># Down.Session.load &quot;mysession&quot;   (* load and execute a session *)</code></pre><p>This is strictly equivalent to issue the <code>#use</code> toplevel directive on the the session file.</p><p>One convention to remember is that the string <code>&quot;&quot;</code> is used in session functions to refer to the name of the last explicit session name you used with one the session functions. This is persisted accross <code>ocaml</code> invocation. For example:</p><pre><code># Down.Session.edit &quot;mysession&quot;   (* edit session &quot;mysession&quot; *)
# Down.Session.load &quot;&quot;            (* load session &quot;mysession&quot; *)
# Down.Session.edit &quot;&quot;            (* edit session &quot;mysession&quot; *)
# ^D
&gt; ocaml
...
# Down.Session.load &quot;&quot;            (* load session &quot;mysession&quot; *)</code></pre><h3 id="recording"><a href="#recording" class="anchor"></a>Recording phrases</h3><p>Another way of creating a session is to record phrases and eventually save them in a session. To start recording phrases use:</p><pre><code># Down.Session.record ()   (* start recording input phrases *)</code></pre><p>Each phrase subsequently input is added to the recorded phrases. Unfortunately due to toplevel API limitations, phrases that error are also recorded. This is why you may want to revise the recorded phrases from time to time to make them coherent:</p><pre><code># Down.Session.revise ()   (* revise recorded phrases *)</code></pre><p>Once you are done you can save the recorded phrases with <code>save</code>:</p><pre><code># Down.Session.save &quot;mysetup&quot;   (* save recorded phrases *)</code></pre><p>This saves the recorded phrases in a new session <code>&quot;mysetup&quot;</code>, stops recording and clears the recorded phrases. The <code>append</code> function works like <code>save</code> but appends the recorded phrases to a session or creates it if it does not exist.</p><pre><code># Down.Session.append &quot;mysetup&quot;   (* like save but appends *)</code></pre><p>Session <code>&quot;mysetup&quot;</code> can now be <code>load</code>ed to play back the recorded phrases. If the sequence happens to have an error when you load it, simply <code>edit</code> the session to correct it and try again.</p><p>If you forget to save the recorded phrases they should be available to <code>revise</code>, <code>save</code> or <code>append</code> the next time you run <code>ocaml</code>.</p><h3 id="stepping"><a href="#stepping" class="anchor"></a>Stepping phrases</h3><p>Stepping through a session allows to reliably paste a sequence of phrases on your prompt. To step through a session issue:</p><pre><code># Down.Session.steps &quot;mysession&quot;   (* define the stepped session  *)</code></pre><p>You can now use <code>shift-{up,down}</code> (or <code>C-x C-{n,p}</code>) to navigate and paste on your prompt the phrases of the session. Like in the <span class="xref-unresolved">history</span> file, steps are delimited by <code>(**)</code> lines in session files. Here's a session with two steps:</p><pre><code>let rec fact = function
| 0 -&gt; 1
| n -&gt; n * fact (n - 1);;
(**)
fact 3;;</code></pre><h3 id="data"><a href="#data" class="anchor"></a>Where is the data ?</h3><p>A session <code>NAME</code> is stored in the plain OCaml file <code>~/.config/ocaml/session/NAME.ml</code>. Except for the fact that <code>(**)</code> lines are used to separate steps for <span class="xref-unresolved">stepping</span> there is nothing special about them and you can edit or <code>#use</code> them directly.</p><p>The file <code>~/.config/ocaml/session/last</code> holds the name of the last session used.</p><p>If you recorded phrases but didn't save them they are persisted in the file <code>~/.config/ocaml/session/unsaved</code> and reloaded on the next <code>ocaml</code> execution.</p><h2 id="id_completion"><a href="#id_completion" class="anchor"></a>Identifier completion and documentation</h2><p>At the moment completion is provided by <a href="https://github.com/OCamlPro/ocp-index"><code>ocp-index</code></a> and is a bit crude. It is <a href="https://github.com/dbuenzli/down/issues/11">planned</a> to improve it in the future but at the moment it is context and <code>open</code> unaware, only library identifiers are completed regardless whether those are loaded or not, identifiers defined during toploop interaction are not completable.</p><p>To complete an identifier put your cursor at the point of completion and hit TAB:</p><pre><code># List.con^t
  List.cons : 'a -&gt; 'a list -&gt; 'a list
  List.concat : 'a list list -&gt; 'a list
# List.con</code></pre><p>Hitting <code>C-t</code> with the cursor over an identifier or on the whitespace right after it shows its documentation:</p><pre><code># List.append^C-t

  List.append : 'a list -&gt; 'a list -&gt; 'a list
  Concatenate two lists.  Same as the infix operator [@].
  Not tail-recursive (length of the first argument).

# List.append</code></pre></div></body></html>