<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Thread_pool (async_unix.Thread_pool)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">async_unix</a> &#x00BB; Thread_pool</nav><header><h1>Module <code>Thread_pool</code></h1><p>A thread pool is a set of OCaml threads used to do work, where each piece of work is simply a thunk. One creates a thread pool, and then uses <code>add_work</code> to submit work to it. Work is done first-come-first-served by available threads in the pool. Any of the available threads in the pool could be used to do work submitted to the pool (except helper threads, see below).</p><p>A thread pool starts with no threads. As work is added, the thread pool creates new threads to do the work, up to the maximum number of allowed threads, <code>max_num_threads</code>, supplied to <code>create</code>. Thread-pool threads never die. They just get created up until <code>max_num_threads</code> is reached and then live forever, doing work. Each thread in the pool is in a loop, waiting for a piece of work, running the thunk, and then repeating. It may be that all the threads in the pool are not doing anything, but in this case, the threads still exist, and are simply blocked waiting for work.</p><p>Sometimes one wants work to run in a dedicated thread, e.g. some C libraries require this. To do this, use <code>Helper_thread</code>, see below.</p><p>All of the functions exposed by this module are thread safe; they synchronize using a mutex on the thread pool.</p><p>One must not call thread-pool functions from a GC finalizer, since a finalizer could run within a thread running a thread-pool function, which already holds the lock, and would therefore deadlock or error when attempting to re-acquire it. This is accomplished elsewhere by using Async finalizers, which are run from ordinary Async jobs, and thus do not hold the thread-pool lock.</p><p>One can control the priority and affinity of threads in the pool (priority in the sense of <code>Linux_ext.setpriority</code>). Work added to the pool can optionally be given a priority, and the pool will set the priority of the thread that runs it for the duration of the work. Helper threads can also be given a priority, which will be used for all work run by the helper thread, unless the work has an overriding priority. The thread pool has a &quot;default&quot; priority that will be used for all work and helper threads that have no specified priority. The default priority is the priority in effect when <code>create</code> is called.</p><p>Affinity, on the other hand, can only be specified when you create a pool. The default affinity is the affinity in effect when a new thread happens to be created (e.g. when you call <code>add_work</code>).</p><p>Behavior is unspecified if work calls <code>setpriority</code> or <code>setaffinity</code> directly.</p></header><div class="content"><div class="spec module" id="module-Cpu_affinity" class="anchored"><a href="#module-Cpu_affinity" class="anchor"></a><code><span class="keyword">module</span> Cpu_affinity = <a href="../../core_kernel/Thread_pool_cpu_affinity/index.html">Thread_pool_cpu_affinity</a></code></div><div class="spec module" id="module-Priority" class="anchored"><a href="#module-Priority" class="anchor"></a><code><span class="keyword">module</span> <a href="Priority/index.html">Priority</a> : <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../../core/Core/Linux_ext/Priority/index.html">Core.Linux_ext.Priority</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../core/Core/Linux_ext/Priority/index.html#type-t">t</a> = <a href="../../core/Core/Linux_ext/Priority/index.html#type-t">Core.Linux_ext.Priority.t</a></code></div><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></div><div><div class="spec include"><div class="doc"><div class="spec value" id="val-sexp_of_t" class="anchored"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></div></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../base/Base/Invariant/module-type-S/index.html">Core.Invariant.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../base/Base/Invariant/module-type-S/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><div class="spec value" id="val-invariant" class="anchored"><a href="#val-invariant" class="anchor"></a><code><span class="keyword">val</span> invariant : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></div></details></div></div></div><div><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span>?&#8288;cpu_affinity:<a href="../../core_kernel/Thread_pool_cpu_affinity/index.html#type-t">Cpu_affinity.t</a></span> <span>&#45;&gt;</span> <span>max_num_threads:int</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a></span></code></div><div><p><code>create ?cpuset ~max_num_threads</code> returns a new thread pool. It is an error if <code>max_num_threads &lt; 1</code>.</p><p>If <code>cpuset</code> is specified, then every thread will be affinitized to those CPU cores upon creation.</p><p>If <code>cpuset</code> is not specified, then every thread will inherit the affinitization of the thread (typically the main thread) that created it.</p></div></div><div><div class="spec value" id="val-cpu_affinity" class="anchored"><a href="#val-cpu_affinity" class="anchor"></a><code><span class="keyword">val</span> cpu_affinity : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../core_kernel/Thread_pool_cpu_affinity/index.html#type-t">Cpu_affinity.t</a></code></div><div><p><code>cpu_affinity t</code> returns the CPU affinity that <code>t</code> was created with. All threads created by <code>t</code> will be created with this affinity.</p></div></div><div><div class="spec value" id="val-finished_with" class="anchored"><a href="#val-finished_with" class="anchor"></a><code><span class="keyword">val</span> finished_with : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></div><div><p><code>finished_with t</code> makes it an error to subsequently call <code>add_work* t</code> or <code>create_helper_thread t</code>. And, once all current work in <code>t</code> is finished, destroys all the threads in <code>t</code>. It is OK to call <code>finished_with</code> multiple times on the same <code>t</code>; subsequent calls will have no effect.</p></div></div><div><div class="spec value" id="val-block_until_finished" class="anchored"><a href="#val-block_until_finished" class="anchor"></a><code><span class="keyword">val</span> block_until_finished : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></div><div><p><code>block_until_finished t</code> blocks the current thread until thread pool <code>t</code> has finished. One must previously have called <code>finished_with</code> to cause <code>t</code> to start finishing.</p></div></div><div><div class="spec value" id="val-max_num_threads" class="anchored"><a href="#val-max_num_threads" class="anchor"></a><code><span class="keyword">val</span> max_num_threads : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></div><div><p><code>max_num_threads t</code> returns the maximum number of threads that <code>t</code> is allowed to create.</p></div></div><div><div class="spec value" id="val-num_threads" class="anchored"><a href="#val-num_threads" class="anchor"></a><code><span class="keyword">val</span> num_threads : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></div><div><p><code>num_threads t</code> returns the number of threads that the pool <code>t</code> has created.</p></div></div><div><div class="spec value" id="val-unfinished_work" class="anchored"><a href="#val-unfinished_work" class="anchor"></a><code><span class="keyword">val</span> unfinished_work : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></div><div><p><code>unfinished_work t</code> returns the number of jobs that have been submitted to <code>t</code> but haven't yet finished.</p></div></div><div><div class="spec value" id="val-default_priority" class="anchored"><a href="#val-default_priority" class="anchor"></a><code><span class="keyword">val</span> default_priority : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Priority/index.html#type-t">Priority.t</a></code></div><div><p><code>default_priority t</code> returns the priority that will be used for work performed by <code>t</code>, unless that work is added with an overriding priority.</p></div></div><div><div class="spec value" id="val-add_work" class="anchored"><a href="#val-add_work" class="anchor"></a><code><span class="keyword">val</span> add_work : <span>?&#8288;priority:<a href="Priority/index.html#type-t">Priority.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;name:string</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span>unit <a href="../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a></span></code></div><div><p><code>add_work ?priority ?name t f</code> enqueues <code>f</code> to be done by some thread in the pool.</p><p>Exceptions raised by <code>f</code> are silently ignored.</p><p>While the work is run, the name of the thread running the work will be set (via <code>Linux_ext.pr_set_name</code>) to <code>name</code> and the priority of the thread will be set to <code>priority</code>.</p><p>It is an error to call <code>add_work t</code> after <code>finished_with t</code>.</p></div></div><div class="spec value" id="val-num_work_completed" class="anchored"><a href="#val-num_work_completed" class="anchor"></a><code><span class="keyword">val</span> num_work_completed : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></div><div><div class="spec value" id="val-has_unstarted_work" class="anchored"><a href="#val-has_unstarted_work" class="anchor"></a><code><span class="keyword">val</span> has_unstarted_work : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></div><div><p><code>has_unstarted_work t</code> returns <code>true</code> if <code>t</code> has work that it hasn't been assigned to start running in a thread.</p></div></div><div><div class="spec module" id="module-Helper_thread" class="anchored"><a href="#module-Helper_thread" class="anchor"></a><code><span class="keyword">module</span> <a href="Helper_thread/index.html">Helper_thread</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><p>A helper thread is a thread with its own dedicated work queue. Work added for the helper thread is guaranteed to be run by that thread. The helper thread only runs work explicitly supplied to it. Helper threads count towards a thread pool's <code>max_num_threads</code>.</p></div></div><div><div class="spec value" id="val-create_helper_thread" class="anchored"><a href="#val-create_helper_thread" class="anchor"></a><code><span class="keyword">val</span> create_helper_thread : <span>?&#8288;priority:<a href="Priority/index.html#type-t">Priority.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;name:string</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="Helper_thread/index.html#type-t">Helper_thread.t</a> <a href="../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a></span></code></div><div><p><code>create_helper_thread ?priority ?name t</code> takes an available thread from the thread pool and makes it a helper thread, raising if no threads are available or if <code>finished_with t</code> was previously called. The new helper thread runs work with <code>name</code> and <code>priority</code>, except for work that is added with an overriding priority or name. The thread remains a helper thread until <code>finished_with_helper_thread</code> is called, if ever.</p></div></div><div><div class="spec value" id="val-become_helper_thread" class="anchored"><a href="#val-become_helper_thread" class="anchor"></a><code><span class="keyword">val</span> become_helper_thread : <span>?&#8288;priority:<a href="Priority/index.html#type-t">Priority.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;name:string</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="Helper_thread/index.html#type-t">Helper_thread.t</a> <a href="../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a></span></code></div><div><p><code>become_helper_thread ?priority ?name t</code> should be run from within work supplied to <code>add_work</code>. When <code>become_helper_thread</code> runs, it transitions the current thread into a helper thread.</p><p>Other than that, <code>become_helper_thread</code> is like <code>create_helper_thread</code>, except it cannot fail because no threads are available.</p></div></div><div><div class="spec value" id="val-add_work_for_helper_thread" class="anchored"><a href="#val-add_work_for_helper_thread" class="anchor"></a><code><span class="keyword">val</span> add_work_for_helper_thread : <span>?&#8288;priority:<a href="Priority/index.html#type-t">Priority.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;name:string</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Helper_thread/index.html#type-t">Helper_thread.t</a> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span>unit <a href="../../core_kernel/Core_kernel/Or_error/index.html#type-t">Core.Or_error.t</a></span></code></div><div><p><code>add_work_for_helper_thread ?priority ?name t helper_thread f</code> enqueues <code>f</code> on <code>helper_thread</code>'s work queue.</p><p>Exceptions raised by <code>f</code> are silently ignored.</p><p>It is an error to call <code>add_work_for_helper_thread t</code> after <code>finished_with_helper_thread t</code>.</p><p>When the helper thread runs <code>f</code>, it will be at the helper thread's name and priority, unless overriden by <code>name</code> or <code>priority</code>.</p></div></div><div><div class="spec value" id="val-finished_with_helper_thread" class="anchored"><a href="#val-finished_with_helper_thread" class="anchor"></a><code><span class="keyword">val</span> finished_with_helper_thread : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Helper_thread/index.html#type-t">Helper_thread.t</a> <span>&#45;&gt;</span> unit</code></div><div><p><code>finished_with_helper_thread t helper_thread</code> informs thread pool <code>t</code> that no future work will be added for <code>helper_thread</code>, and makes it an error to in the future add work for <code>helper_thread</code>. Furthermore, once <code>helper_thread</code> finishes with its last piece of work, it will revert to a general thread-pool thread. It is OK to call <code>finished_with_helper_thread</code> multiple times on the same <code>helper_thread</code>; subsequent calls will have no effect.</p></div></div><div class="spec value" id="val-last_thread_creation_failure" class="anchored"><a href="#val-last_thread_creation_failure" class="anchor"></a><code><span class="keyword">val</span> last_thread_creation_failure : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../../core_kernel/Core_kernel/Sexp/index.html#type-t">Core.Sexp.t</a> option</span></code></div><div class="spec value" id="val-thread_creation_failure_lockout" class="anchored"><a href="#val-thread_creation_failure_lockout" class="anchor"></a><code><span class="keyword">val</span> thread_creation_failure_lockout : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../core/Core/Time_ns/Span/index.html#type-t">Core.Time_ns.Span.t</a></code></div><div class="spec value" id="val-debug" class="anchored"><a href="#val-debug" class="anchor"></a><code><span class="keyword">val</span> debug : <span>bool <a href="../../core/Core/index.html#type-ref">Core.ref</a></span></code></div></div></body></html>