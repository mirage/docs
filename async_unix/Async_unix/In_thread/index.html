<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>In_thread (async_unix.Async_unix.In_thread)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> – <a href="../../index.html">async_unix</a> &#x00BB; <a href="../index.html">Async_unix</a> &#x00BB; In_thread</nav><header><h1>Module <code>Async_unix.In_thread</code></h1><p>The <code>In_thread</code> module has functions for interaction between the Async world and other (kernel) threads. The name is to remind us to think about threads and race conditions.</p><p>All threads come from the one thread pool used for all Async-managed threads.</p></header><div class="content"><div class="spec module" id="module-Priority" class="anchored"><a href="#module-Priority" class="anchor"></a><code><span class="keyword">module</span> <a href="Priority/index.html">Priority</a> : <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../../../core/Core/Linux_ext/Priority/index.html">Core.Linux_ext.Priority</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../../core/Core/Linux_ext/Priority/index.html#type-t">t</a> = <a href="../../../core/Core/Linux_ext/Priority/index.html#type-t">Core.Linux_ext.Priority.t</a></code></div><div class="spec module" id="module-Helper_thread" class="anchored"><a href="#module-Helper_thread" class="anchor"></a><code><span class="keyword">module</span> <a href="Helper_thread/index.html">Helper_thread</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec value" id="val-pipe_of_squeue" class="anchored"><a href="#val-pipe_of_squeue" class="anchor"></a><code><span class="keyword">val</span> pipe_of_squeue : <span><span class="type-var">'a</span> <a href="../../../core/Squeue/index.html#type-t">Squeue.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Pipe/Reader/index.html#type-t">Async_kernel.Pipe.Reader.t</a></span></code></div><div><p><code>pipe_of_squeue squeue</code> returns a pipe <code>p</code> and consumes the contents <code>squeue</code>, placing them in <code>p</code>. It repeatedly grabs everything from <code>squeue</code>, places it in <code>p</code>, and then waits for pushback on <code>p</code>.</p></div></div><div><div class="spec module" id="module-When_finished" class="anchored"><a href="#module-When_finished" class="anchor"></a><code><span class="keyword">module</span> <a href="When_finished/index.html">When_finished</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><p><code>When_finished</code> describes how <code>In_thread.run f</code> behaves when the helper thread finishes <code>f ()</code>.</p></div></div><div><div class="spec value" id="val-run" class="anchored"><a href="#val-run" class="anchor"></a><code><span class="keyword">val</span> run : <span>?&#8288;priority:<a href="Priority/index.html#type-t">Priority.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;thread:<a href="Helper_thread/index.html#type-t">Helper_thread.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;when_finished:<a href="When_finished/index.html#type-t">When_finished.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;name:string</span> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p><code>run ?priority ?thread ?name f</code> runs <code>f ()</code> in a separate thread outside Async and returns the result as a Deferred in the Async world. If <code>f ()</code> raises an exception (asynchronously, since it is another thread) then that exception will be raised to the monitor that called <code>run</code>.</p><p>WARNING: Async code MUST NOT be used from within <code>f</code>. By Async code we mean pretty-much all functions of libraries making use of Async. Only a few functions of the Async library can be called inside <code>In_thread.run</code>. These are explicitly marked as such, using the phrase &quot;thread-safe&quot;.</p><p>If <code>thread</code> is not supplied, then any thread from the thread pool could be used. If you need to run routines in a specific thread (as is required by some libraries like Sqlite), you should create a helper thread and supply it to <code>run</code>.</p><p>If <code>priority</code> is supplied, the priority of the thread in the linux scheduler will be set to <code>priority</code> for the duration of <code>f ()</code>, provided the thread is allowed to do so (see <code>man setpriority</code>).</p><p>If you call <code>run</code> several times with the same helper thread, the <code>f ()</code> calls will run in sequence, in the order in which they are supplied to <code>run</code>. Each <code>f ()</code> will complete (return or raise) before another <code>f ()</code> starts.</p><p>For example, if you do:</p><pre><code>let () =
  run ~thread f1;
  run ~thread f2;
  run ~thread f3; </code></pre><p>Then the thread will run <code>f1 ()</code> to completion, then <code>f2 ()</code> to completion, then <code>f3 ()</code> to completion.</p><p>If <code>name</code> is supplied, the name of the thread will be set to it for the duration of the execution of <code>f ()</code>.</p><p><code>when_finished</code> describes how the helper thread behaves once <code>f ()</code> has completed. Its default value is the value of <a href="When_finished/index.html#val-default"><code>When_finished.default</code></a> when <code>run</code> is called.</p></div></div><div><div class="spec value" id="val-syscall" class="anchored"><a href="#val-syscall" class="anchor"></a><code><span class="keyword">val</span> syscall : <span>name:string</span> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'a</span>, exn)</span> <a href="../../../core_kernel/Core_kernel/Result/index.html#type-t">Core.Result.t</a></span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p><code>syscall f</code> runs f, which should be a single system call, and returns the result, handling the restarting of interrupted system calls. To avoid race conditions, the <code>f</code> supplied to <code>syscall</code> should just make a system call. That way, everything else is done holding the Async lock.</p></div></div><div class="spec value" id="val-syscall_exn" class="anchored"><a href="#val-syscall_exn" class="anchor"></a><code><span class="keyword">val</span> syscall_exn : <span>name:string</span> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div></div></body></html>