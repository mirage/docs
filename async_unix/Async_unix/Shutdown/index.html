<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Shutdown (async_unix.Async_unix.Shutdown)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v1.1.1-1373-g2e7c1c75"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">async_unix</a> &#x00BB; <a href="../index.html">Async_unix</a> &#x00BB; Shutdown</nav><header><h1>Module <code>Async_unix.Shutdown</code></h1><p>For shutting down an Async program.</p></header><div class="content"><div><div class="spec value" id="val-shutdown" class="anchored"><a href="#val-shutdown" class="anchor"></a><code><span class="keyword">val</span> shutdown : <span>?&#8288;force:<span>unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></div><div><p><code>shutdown ?force status</code> initiates shutdown, which runs all the <code>at_shutdown</code> functions, waits for them to finish, and then exits with the supplied status. The <code>at_shutdown</code> functions can block -- one can use <code>~force</code> to forcibly exit (with status 1) if the <code>at_shutdown</code> functions do not finish in a reasonable amount of time.</p><p>By default, <code>force</code> is <code>after (sec 10.)</code>.</p><p>Repeated calls to <code>shutdown</code> with the same status will have no effect. Any call to <code>shutdown</code> with nonzero status will cause that to be the status that is exited with. A call to <code>shutdown</code> with different nonzero status from the original call will raise.</p></div></div><div><div class="spec value" id="val-shutdown_on_unhandled_exn" class="anchored"><a href="#val-shutdown_on_unhandled_exn" class="anchor"></a><code><span class="keyword">val</span> shutdown_on_unhandled_exn : unit <span>&#45;&gt;</span> unit</code></div><div><p><code>shutdown_on_unhandled_exn ()</code> arranges things so that whenever there is an asynchronous unhandled exception, an error message is printed to stderr and <code>shutdown
    1</code> is called. This is useful when one wants to ensure that <code>at_shutdown</code> handlers run when there is an unhandled exception. Calling <code>shutdown_on_unhandled_exn</code> ensures that <code>Scheduler.go</code> will not raise due to an unhandled exception, and instead that the program will exit once <code>at_shutdown</code> handlers finish.</p></div></div><div><div class="spec value" id="val-exit" class="anchored"><a href="#val-exit" class="anchor"></a><code><span class="keyword">val</span> exit : <span>?&#8288;force:<span>unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p><code>exit ?force status</code> is <code>shutdown ?force status; Deferred.never ()</code>.</p><p>We do not have an exit function that returns a non-deferred:</p><pre><code>val exit : ?force:unit Deferred.t -&gt; int -&gt; _ </code></pre><p>Such a function should not exist, for the same reason that we do not have:</p><pre><code>val block : 'a Deferred.t -&gt; 'a </code></pre><p>The semantics of such an exit function would allow one to block a running Async job, and to switch to another one (to run the <code>at_shutdown</code> handlers), without expressing that switch in the type system via a <code>Deferred.t</code>. That would eliminate all the nice reasoning guarantees that Async gives about concurrent jobs.</p></div></div><div><div class="spec value" id="val-default_force" class="anchored"><a href="#val-default_force" class="anchor"></a><code><span class="keyword">val</span> default_force : unit <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span>unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span></code></div><div><p><code>default_force</code> returns the default <code>force</code> value used by <code>shutdown</code> and <code>exit</code>.</p></div></div><div><div class="spec value" id="val-set_default_force" class="anchored"><a href="#val-set_default_force" class="anchor"></a><code><span class="keyword">val</span> set_default_force : <span>(unit <span>&#45;&gt;</span> <span>unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span>)</span> <span>&#45;&gt;</span> unit</code></div><div><p><code>set_default_force f</code> sets the default <code>force</code> value used by <code>shutdown</code> and <code>exit</code> to <code>f</code>. Initially, the default value is <code>fun () -&gt; after (sec 10.)</code>. A subsequent call to <code>shutdown</code> or <code>exit</code> that doesn't supply <code>~force</code> will call <code>f</code> and will force shutdown when its result becomes determined.</p><p><code>set_default_force</code> has no effect if <code>shutdown</code> or <code>exit</code> has already been called, or if the next call to <code>shutdown</code> or <code>exit</code> supplies <code>~force</code>.</p><p><code>set_default_force</code> is useful for applications that call <code>shutdown</code> indirectly via a library, yet want to modify its behavior.</p></div></div><div><div class="spec value" id="val-shutting_down" class="anchored"><a href="#val-shutting_down" class="anchor"></a><code><span class="keyword">val</span> shutting_down : unit <span>&#45;&gt;</span> <span>[ `No <span><span>| `Yes</span> of int</span> ]</span></code></div><div><p><code>shutting_down ()</code> reports whether we are currently shutting down, and if so, with what status.</p></div></div><div class="spec value" id="val-is_shutting_down" class="anchored"><a href="#val-is_shutting_down" class="anchor"></a><code><span class="keyword">val</span> is_shutting_down : unit <span>&#45;&gt;</span> bool</code></div><div><div class="spec value" id="val-at_shutdown" class="anchored"><a href="#val-at_shutdown" class="anchor"></a><code><span class="keyword">val</span> at_shutdown : <span>(unit <span>&#45;&gt;</span> <span>unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span>)</span> <span>&#45;&gt;</span> unit</code></div><div><p><code>at_shutdown f</code> causes <code>f ()</code> to be run when <code>shutdown</code> is called, and for <code>shutdown</code> to wait until the returned deferred finishes. If <code>f</code> raises (synchronously or asynchronously), then the exception is printed to stderr and the program exits nonzero, irrespective of the status supplied to <code>shutdown</code>.</p><p>If <code>shutdown</code> has already been called, then calling <code>at_shutdown f</code> does nothing.</p><p>The functions supplied to <code>at_shutdown</code> are run in parallel on shutdown.</p></div></div><div><div class="spec value" id="val-don't_finish_before" class="anchored"><a href="#val-don't_finish_before" class="anchor"></a><code><span class="keyword">val</span> don't_finish_before : <span>unit <a href="../../../async_kernel/Async_kernel/Deferred/index.html#type-t">Async_kernel.Deferred.t</a></span> <span>&#45;&gt;</span> unit</code></div><div><p><code>don't_finish_before d</code> causes <code>shutdown</code> to wait until <code>d</code> becomes determined before finishing. It is like <code>at_shutdown (fun _ -&gt; d)</code>, except it is more efficient, and will not take any space once <code>d</code> is determined. There is a single <code>at_shutdown</code> shared among all deferreds supplied to <code>don't_finish_before</code>. <code>don't_finish_before</code> does not override the <code>force</code> argument passed to shutdown.</p></div></div></div></body></html>